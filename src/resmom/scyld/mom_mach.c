/*
 * Copyright (C) 1994-2018 Altair Engineering, Inc.
 * For more information, contact Altair at www.altair.com.
 *
 * This file is part of the PBS Professional("PBS Pro") software.
 *
 * Open Source License Information:
 *
 * PBS Pro is free software. You can redistribute it and/or modify it under the
 * terms of the GNU Affero General Public License as published by the Free
 * Software Foundation, either version 3 of the License, or (at your option) any
 * later version.
 *
 * PBS Pro is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.
 * See the GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Commercial License Information:
 *
 * For a copy of the commercial license terms and conditions,
 * go to: (http://www.pbspro.com/UserArea/agreement.html)
 * or contact the Altair Legal Department.
 *
 * Altair’s dual-license business model allows companies, individuals, and
 * organizations to create proprietary derivative works of PBS Pro and
 * distribute them - whether embedded or bundled with other software -
 * under a commercial license agreement.
 *
 * Use of Altair’s trademarks, including but not limited to "PBS™",
 * "PBS Professional®", and "PBS Pro™" and Altair’s logos is subject to Altair's
 * trademark licensing policies.
 *
 */

#include <pbs_config.h>   /* the master config generated by configure */

#include <assert.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <unistd.h>
#include <dirent.h>
#include <fcntl.h>
#include <errno.h>
#include <string.h>
#include <pwd.h>
#include <time.h>
#include <mntent.h>
#include <asm/types.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/procfs.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/vfs.h>
#include <sys/sysmacros.h>
#include <sys/resource.h>
#include <sys/bproc.h>
#include <sys/beostat.h>
#include <syscall.h>

#include "pbs_error.h"
#include "portability.h"
#include "list_link.h"
#include "server_limits.h"
#include "attribute.h"
#include "resource.h"
#include "job.h"
#include "log.h"
#include "mom_func.h"
#include "mom_mach.h"
#include "pbs_nodes.h"
#include "resmon.h"
#include "../rm_dep.h"
#include "pbs_license.h"


/**
 * @file
 * @brief
 *	System dependent code to gather information for the resource
 *	monitor for a Linux i386 machine.
 *
 * @par	Resources known by this code:
 *		cput		cpu time for a pid or session
 *		mem		memory size for a pid or session in KB
 *		resi		resident memory size for a pid or session in KB
 *		sessions	list of sessions in the system
 *		pids		list of pids in a session
 *		nsessions	number of sessions in the system
 *		nusers		number of users in the system
 *		totmem		total memory size in KB
 *		availmem	available memory size in KB
 *		ncpus		number of cpus
 *		physmem		physical memory size in KB
 *		size		size of a file or filesystem
 *		idletime	seconds of idle time (see mom_main.c)
 *		walltime	wall clock time for a pid
 *		loadave		current load average
 */


#ifndef TRUE
#define FALSE	0
#define TRUE	1
#endif	/* TRUE */

#define TBL_INC 20

static	char     procfs[] = "/proc";
static	DIR	*pdir = NULL;
static	int	 pagesize;
proc_stat_t	*proc_info = NULL;
int		 nproc = 0;
int		 max_proc = 0;
int		 mom_does_chkpnt = 0;

struct	bnode	*node_array = NULL;

extern	char	*ret_string;
extern	char	extra_parm[];
extern	char	no_parm[];
extern	int	exiting_tasks;

extern	time_t	time_now;

/*
 ** external functions and data
 */
extern  int	nice_val;
extern	struct	config		*search(struct config *, char *);
extern	struct	rm_attribute	*momgetattr(char *);
extern	int			rm_errno;
extern	int			reqnum;
extern	double	cputfactor;
extern	double	wallfactor;

/*
 ** local functions and data
 */
static	char	*resi		(struct rm_attribute *attrib);
static	char	*totmem		(struct rm_attribute *attrib);
static	char	*availmem	(struct rm_attribute *attrib);
char	*physmem	(struct rm_attribute *attrib);
static	char	*ncpus		(struct rm_attribute *attrib);
static	char	*walltime	(struct rm_attribute *attrib);

extern	char	*loadave	(struct rm_attribute *attrib);
extern	char	*nullproc	(struct rm_attribute *attrib);

time_t	wait_time = 10;

typedef	struct	proc_mem  {
	unsigned	total;
	unsigned	used;
	unsigned	free;
} proc_mem_t;

static  int     myproc_max = 0;		/* entries in Proc_lnks  */
pbs_plinks     *Proc_lnks = NULL;       /* process links table head */
static time_t   sampletime_ceil;
static time_t   sampletime_floor;


/*
 ** local resource array
 */
struct	config	dependent_config[] = {
	{ "resi",	{ resi } },
	{ "totmem",	{ totmem } },
	{ "availmem",	{ availmem } },
	{ "physmem",	{ physmem } },
	{ "ncpus",	{ ncpus } },
	{ "loadave",	{ loadave } },
	{ "walltime",	{ walltime } },
	{ NULL,		{ nullproc } },
};

unsigned linux_time = 0;
/*
 * support routine for getting system time -- sets linux_time
 */
void
proc_get_btime()
{
	FILE	*fp;
	char	label[256];


	if ((fp = fopen("/proc/stat", "r")) == NULL)
		return;

	while (!feof(fp)) {
		fscanf(fp, "%s", label);
		if (strcmp(label, "btime")) {
			fscanf(fp, "%*[^\n]%*c");
		}  else  {
			fscanf(fp, "%u", &linux_time);
			fclose(fp);
			return;
		}
	}

	fclose(fp);
	return;
}

static	char	stat_str[] = "%d (%[^)]) %c %d %d %d %*d %*d %u %*u \
%*u %*u %*u %d %d %d %d %*d %*d %*u %*u %u %u %u %*u %*u \
%*u %*u %*u %*u %*u %*u %*u %*u %*u %*u %*u";

/*
 **	Convert jiffies to seconds.
 */
#define	JTOS(x)  x = (x + CLOCKS_PER_SEC/2) / CLOCKS_PER_SEC;


proc_mem_t      *
get_proc_mem()
{
	static	proc_mem_t	mm;
	FILE    	*fp;
	unsigned        m_tot, m_use, m_free;
	unsigned        s_tot, s_use, s_free;


	if ((fp = fopen("/proc/meminfo", "r")) == NULL)
		return (NULL);

	fscanf(fp, "%*[^\n]%*c");       /* lose the text header */;
	fscanf(fp, "%*s %u %u %u %*[^\n]%*c", &m_tot, &m_use, &m_free);
	fscanf(fp, "%*s %u %u %u %*[^\n]%*c", &s_tot, &s_use, &s_free);

	mm.total = m_tot + s_tot;
	mm.used = m_use + s_use;
	mm.free = m_free + s_free;

	fclose(fp);
	return (&mm);
}

/**
 * @brief
 *      initialize the platform-dependent topology information
 *
 * @return      Void
 *
 */
void
dep_initialize()
{
	int			i;

	DBPRT(("%s: entered\n", __func__))
	pagesize = getpagesize();

	if ((pdir = opendir(procfs)) == NULL) {
		log_err(errno, __func__, "opendir");
		return;
	}

	proc_get_btime();

	num_pcpus = bproc_numnodes();
	i = bproc_currnode();
	if (i != -1) {
		log_err(-1, __func__, "MOM not running on master node");
		return;
	}

	node_array = calloc(num_pcpus, sizeof(*node_array));
	if (node_array == NULL) {
		return;
	}

	/* set all nodes owned by root */
	for (i=0; i<num_pcpus; i++) {
		struct	bnode	*np = &node_array[i];

		if (bproc_chown(i, 0) != 0 && errno != ENOENT) {
			sprintf(log_buffer, "bproc_chown node %d", i);
			log_err(errno, __func__, log_buffer);
		}
		if (bproc_chgrp(i, 0) != 0 && errno != ENOENT) {
			sprintf(log_buffer, "bproc_chgrp node %d", i);
			log_err(errno, __func__, log_buffer);
		}
		if (bproc_chmod(i, 0) != 0 && errno != ENOENT) {
			sprintf(log_buffer, "bproc_chmod node %d", i);
			log_err(errno, __func__, log_buffer);
		}
	}

	(void)ncpus(NULL);
	return;
}

/**
 * @brief
 *      clean up platform-dependent topology information
 *
 * @return      Void
 *
 */
void
dep_cleanup()
{
	int	i;

	if (pdir) {
		closedir(pdir);
		pdir = NULL;
	}
	if (node_array != NULL) {
		free(node_array);
		node_array = NULL;
	}

	/* set all nodes assesable by any */
	for (i=0; i<num_pcpus; i++) {
		if (bproc_chmod(i, S_IXUSR|S_IXGRP|S_IXOTH) != 0 &&
			errno != ENOENT) {
			sprintf(log_buffer, "bproc_chmod node %d", i);
			log_err(errno, __func__, log_buffer);
		}
	}
}

/**
 * @brief
 *      Don't need any periodic procsessing except in some special cases.
 *
 * @return      Void
 *
 */
void
end_proc()
{
	(void)ncpus(NULL);
	return;
}

/**
 * @brief
 *       Scan a list of tasks and return true if one of them matches sid
 *
 * @param[in] pjob - job pointer
 * @param[in] sid - session id
 *
 * @return      Bool
 * @retval      TRUE    
 * @retval      FALSE   Error
 *
 */
static int
injob(job *pjob, pid_t sid)
{
	task    *ptask;

	for (ptask = (task *)GET_NEXT(pjob->ji_tasks);
		ptask;
		ptask = (task *)GET_NEXT(ptask->ti_jobtask)) {
		if (ptask->ti_qs.ti_sid <= 1)
			continue;
		if (ptask->ti_qs.ti_sid == sid)
			return TRUE;
	}
	return FALSE;
}

/**
 * @brief
 *      Internal session cpu time decoding routine.
 *
 * @param[in] job - a job pointer.
 *
 * @return      ulong
 * @retval      sum of all cpu time consumed for all tasks executed by the job, in seconds,
 *              adjusted by cputfactor.
 *
 */
static unsigned long
cput_sum(job *pjob)
{
	DOID("cput_ses")
	int			i;
	ulong			cputime = 0;
	int			nps = 0;
	int			taskprocs;
	proc_stat_t		*ps;
	task			*ptask;
	ulong			tcput;


	for (ptask = (task *)GET_NEXT(pjob->ji_tasks);
		ptask != NULL;
		ptask = (task *)GET_NEXT(ptask->ti_jobtask)) {

		/* DEAD task */
		if (ptask->ti_qs.ti_sid <= 1) {
			cputime += ptask->ti_cput;
			continue;
		}

		tcput = 0;
		taskprocs = 0;
		for (i=0; i<nproc; i++) {
			ps = &proc_info[i];

			/* is this process part of the task? */
			if (ptask->ti_qs.ti_sid != ps->session)
				continue;

			nps++;
			taskprocs++;
			tcput += (ps->utime + ps->stime +
				ps->cutime + ps->cstime);
			DBPRT(("%s: ses %d pid %d cputime %lu\n",
				id, ps->session, ps->pid, tcput));
		}

		if (tcput > ptask->ti_cput)
			ptask->ti_cput = tcput;
		cputime += ptask->ti_cput;
		DBPRT(("%s: task %08.8X cput %lu total %lu\n", id,
			ptask->ti_qs.ti_task, ptask->ti_cput, cputime))

		if (taskprocs == 0) {
			sprintf(log_buffer,
				"no active process for task %8.8X",
				ptask->ti_qs.ti_task);
			log_event(PBSEVENT_JOB, PBS_EVENTCLASS_JOB,
				LOG_INFO, pjob->ji_qs.ji_jobid,
				log_buffer);
			ptask->ti_qs.ti_exitstat = 0;
			ptask->ti_qs.ti_status = TI_STATE_EXITED;
			if (pjob->ji_qs.ji_un.ji_momt.ji_exitstat >= 0)
				pjob->ji_qs.ji_un.ji_momt.ji_exitstat = 0;
			task_save(ptask);
			exiting_tasks = 1;
		}
	}

	if (nps == 0)
		pjob->ji_flags |= MOM_NO_PROC;

	return ((unsigned long)((double)cputime * cputfactor));
}

/**
 * @brief
 *      Internal session memory usage function.
 *
 * @param[in] job - job pointer
 *
 * @return      ulong
 * @retval      the total number of bytes of address
 *              space consumed by all current processes within the job.
 *
 */
static unsigned long 
mem_sum(job *pjob)
{
	int			i;
	ulong			segadd;
	proc_stat_t		*ps;

	segadd = 0;

	for (i=0; i<nproc; i++) {

		ps = &proc_info[i];

		if (!injob(pjob, ps->session))
			continue;
		segadd += ps->vsize;
		DBPRT(("%s: pid: %d  pr_size: %lu  total: %lu\n",
			__func__, ps->pid, (ulong)ps->vsize, segadd))
	}

	return (segadd);
}

/**
 * @brief
 *      Internal session workingset size function.
 *
 * @param[in] pjob - job pointer
 *
 * @return      ulong
 * @retval      new resident set size   Success
 * @retval      old resident set size   Error
 *      
 */
static unsigned long 
resi_sum(job *pjob)
{
	int		 i;
	ulong		 resisize;
	proc_stat_t	*ps;

	resisize = 0;
	for (i=0; i<nproc; i++) {

		ps = &proc_info[i];

		if (!injob(pjob, ps->session))
			continue;

		resisize += ps->rss * pagesize;
	}

	return (resisize);
}

/**
 * @brief
 *	Set nodes to be inuse by a given job or return error.
 *
 * @param[in] jp - job pointer
 * @param[in] num - 
 */
int
alloc_nodes(job *jp, int num)
{
	int	i;
	int	found = 0;

	DBPRT(("%s: entered %d\n", __func__, num))
	if (num > num_pcpus)
		return PBSE_BADATVAL;

	for (i=0; i<num_pcpus; i++) {
		struct	bnode	*np = &node_array[i];

		if (np->n_job != jp)
			continue;

		DBPRT(("%s: alloc node %d\n", __func__, i))
		if (bproc_chown(i, jp->ji_qs.ji_un.ji_momt.ji_exuid) != 0) {
			sprintf(log_buffer, "bproc_chmod node %d", i);
			log_err(errno, __func__, log_buffer);
			return PBSE_SYSTEM;
		}
		if (bproc_chgrp(i, jp->ji_qs.ji_un.ji_momt.ji_exgid) != 0) {
			sprintf(log_buffer, "bproc_chgrp node %d", i);
			log_err(errno, __func__, log_buffer);
			return PBSE_SYSTEM;
		}
		if (bproc_chmod(i, S_IXUSR) != 0) {
			sprintf(log_buffer, "bproc_chmod node %d", i);
			log_err(errno, __func__, log_buffer);
			return PBSE_SYSTEM;
		}

		found += np->n_cpus;
	}
	if (found < num) {
		log_err(-1, __func__, "insufficient nodes");
		return PBSE_BADATVAL;
	}

	return PBSE_NONE;
}

/**
 * @brief
 *      Establish system-enforced limits for the job.
 *
 *      Run through the resource list, checking the values for all items
 *      we recognize.
 *
 * @param[in] pjob - job pointer
 * @param[in]  set_mode - setting mode
 *
 *      If set_mode is SET_LIMIT_SET, then also set hard limits for the
 *                        system enforced limits (not-polled).
 *      If anything goes wrong with the process, return a PBS error code
 *      and print a message on standard error.  A zero-length resource list
 *      is not an error.
 *
 *      If set_mode is SET_LIMIT_SET the entry conditions are:
 *          1.  MOM has already forked, and we are called from the child.
 *          2.  The child is still running as root.
 *          3.  Standard error is open to the user's file.
 *
 *      If set_mode is SET_LIMIT_ALTER, we are beening called to modify
 *      existing limits.  Cannot alter those set by setrlimit (kernel)
 *      because we are the wrong process.
 *
 * @return      int
 * @retval      PBSE_NONE       Success
 * @retval      PBSE_*          Error
 *
 */
int
mom_set_limits(job *pjob, int set_mode)
{
	char		*pname;
	int		retval;
	unsigned long	value;	/* place in which to build resource value */
	resource	*pres;
	struct rlimit	reslim;
	unsigned long	mem_limit  = 0;
	unsigned long	vmem_limit  = 0;
	unsigned long	cput_limit  = 0;

	DBPRT(("%s: entered\n", __func__))
	assert(pjob != NULL);
	assert(pjob->ji_wattr[(int)JOB_ATR_resource].at_type == ATR_TYPE_RESC);
	pres = (resource *)
		GET_NEXT(pjob->ji_wattr[(int)JOB_ATR_resource].at_val.at_list);

	/*
	 * Cycle through all the resource specifications,
	 * setting limits appropriately.
	 */

	/* mem and vmem limits come from the local node limits, not the job */
	mem_limit  = pjob->ji_hosts[pjob->ji_nodeid].hn_nrlimit.rl_mem << 10;
	vmem_limit = pjob->ji_hosts[pjob->ji_nodeid].hn_nrlimit.rl_vmem << 10;

	while (pres != NULL) {
		assert(pres->rs_defin != NULL);
		pname = pres->rs_defin->rs_name;
		assert(pname != NULL);
		assert(*pname != '\0');

		if (strcmp(pname, "ncpus") == 0) {
			value = pres->rs_value.at_val.at_long;
			retval = alloc_nodes(pjob, value);
			if (retval != PBSE_NONE)
				return (error(pname, retval));
		} else if (strcmp(pname, "cput") == 0 ||
			strcmp(pname, "pcput") == 0) {
			retval = local_gettime(pres, &value);
			if (retval != PBSE_NONE)
				return (error(pname, retval));
			if ((cput_limit == 0) || (value < cput_limit))
				cput_limit = value;
		} else if (strcmp(pname, "pvmem") == 0) {
			retval = local_getsize(pres, &value);
			if (retval != PBSE_NONE)
				return (error(pname, retval));
			if ((vmem_limit == 0) || (value < vmem_limit))
				vmem_limit = value;
		} else if (strcmp(pname, "pmem") == 0) {	/* set */
			retval = local_getsize(pres, &value);
			if (retval != PBSE_NONE)
				return (error(pname, retval));
			if ((mem_limit == 0) || (value < mem_limit))
				mem_limit = value;
		} else if (strcmp(pname, "walltime") == 0) {	/* Check */
			retval = local_gettime(pres, &value);
			if (retval != PBSE_NONE)
				return (error(pname, retval));
		} else if (strcmp(pname, "nice") == 0) {	/* set nice */
			if (set_mode == SET_LIMIT_SET) {
				errno = 0;
				if ((nice((int)pres->rs_value.at_val.at_long) == -1)
					&& (errno != 0))
					return (error(pname, PBSE_BADATVAL));
			}
		} else if (strcmp(pname, "file") == 0) {	/* set */
			if (set_mode == SET_LIMIT_SET) {
				retval = local_getsize(pres, &value);
				if (retval != PBSE_NONE)
					return (error(pname, retval));
				reslim.rlim_cur = reslim.rlim_max = value;
				if (setrlimit(RLIMIT_FSIZE, &reslim) < 0)
					return (error(pname, PBSE_SYSTEM));
			}
		}
		pres = (resource *)GET_NEXT(pres->rs_link);
	}

	if (set_mode == SET_LIMIT_SET) {
		/* if either of vmem or pvmem was given, set sys limit to lesser */
		if (vmem_limit != 0) {
			reslim.rlim_cur = reslim.rlim_max = vmem_limit;
			if (setrlimit(RLIMIT_AS, &reslim) < 0)
				return (error("RLIMIT_AS", PBSE_SYSTEM));
		}

		/* if either mem or pmem was given, set sys limit to lesser */
		if (mem_limit != 0) {
			reslim.rlim_cur = reslim.rlim_max = mem_limit;
			if (setrlimit(RLIMIT_RSS, &reslim) < 0)
				return (error("RLIMIT_RSS", PBSE_SYSTEM));
		}

		/* if either cput or pcput was given, set sys limit to lesser */
		if (cput_limit != 0) {
			reslim.rlim_cur = reslim.rlim_max =
				(unsigned long)((double)cput_limit / cputfactor);
			if (setrlimit(RLIMIT_CPU, &reslim) < 0)
				return (error("RLIMIT_CPU", PBSE_SYSTEM));
		}
	}
	return (PBSE_NONE);
}

/**
 * @brief
 *      State whether MOM main loop has to poll this job to determine if some
 *      limits are being exceeded.
 *
 * @param[in] pjob - job pointer
 *
 * @return      int
 * @retval      TRUE    if polling is necessary
 * @retval      FALSE   otherwise. 
 *
 * NOTE: Actual polling is done using the mom_over_limit machine-dependent function.
 *
 */
int
mom_do_poll(job *pjob)
{
	char		*pname;
	resource	*pres;

	DBPRT(("%s: entered\n", __func__))
	assert(pjob != NULL);
	assert(pjob->ji_wattr[(int)JOB_ATR_resource].at_type == ATR_TYPE_RESC);
	pres = (resource *)
		GET_NEXT(pjob->ji_wattr[(int)JOB_ATR_resource].at_val.at_list);

	while (pres != NULL) {
		assert(pres->rs_defin != NULL);
		pname = pres->rs_defin->rs_name;
		assert(pname != NULL);
		assert(*pname != '\0');

		if (strcmp(pname, "walltime") == 0 ||
			strcmp(pname, "cput") == 0 ||
			strcmp(pname, "mem")  == 0 ||
			strcmp(pname, "vmem") == 0)
			return (TRUE);
		pres = (resource *)GET_NEXT(pres->rs_link);
	}

	return (FALSE);
}

/**
 * @brief
 *      Setup for polling.
 *      Open kernel device and get namelist info.
 *
 * @return      int
 * @retval      PBSE_NONE               Success
 * @retval      PBSE_SYSTEM             Error
 *
 */
int
mom_open_poll(void)
{
	DBPRT(("%s: entered\n", __func__))
	pagesize = getpagesize();
	proc_info = (proc_stat_t *)malloc(sizeof(proc_stat_t) * TBL_INC);
	if (proc_info == NULL) {
		log_err(errno, __func__, "malloc");
		return (PBSE_SYSTEM);
	}
	max_proc = TBL_INC;

	return (PBSE_NONE);
}

/**
 * @brief
 * 	Declare start of polling loop.
 * @return int
 * @retval PBSE_INTERNAL Dir pdir is NULL
 * @retval PBSE_NONE     Success
 */

int
mom_get_sample()
{
	struct  dirent          *dent;
	FILE                    *fd;
	unsigned		 jiffies;
	static char		 path[1024];
	char                     procname[256];
	struct 	stat		 sb;
	proc_stat_t		*ps;

	extern time_t 		 time_last_sample;

	DBPRT(("%s: entered\n", __func__))
	if (pdir == NULL)
		return PBSE_INTERNAL;

	rewinddir(pdir);
	nproc = 0;
	fd = NULL;
	time_last_sample = time_now;
	sampletime_floor = time_last_sample;
	while (errno = 0, (dent = readdir(pdir)) != NULL) {
		if (!isdigit(dent->d_name[0]))
			continue;
		sprintf(procname, "/proc/%s/stat", dent->d_name);

		if ((fd = fopen(procname, "r")) == NULL)
			continue;

		ps = &proc_info[nproc];
		if (fscanf(fd, stat_str, &ps->pid, path, &ps->state,
			&ps->ppid, &ps->pgrp,
			&ps->session, &ps->flags, &ps->utime, &ps->stime,
			&ps->cutime, &ps->cstime, &jiffies, &ps->vsize,
			&ps->rss) != 14) {
			fclose(fd);
			continue;
		}
		if (fstat(fileno(fd), &sb) == -1) {
			fclose(fd);
			continue;
		}  else  {
			ps->uid = sb.st_uid;
		}
		fclose(fd);

		ps->start_time = linux_time + (jiffies / CLOCKS_PER_SEC);
		memset(ps->comm, 0, COMSIZE);
		strncpy(ps->comm, path, COMSIZE-1);

		JTOS(ps->utime)
		JTOS(ps->stime)
		JTOS(ps->cutime)
		JTOS(ps->cstime)

		if (++nproc == max_proc) {
			void    *hold;
			DBPRT(("%s: alloc more proc table space %d\n", __func__, nproc))
			max_proc += TBL_INC;
			hold = realloc((void *)proc_info,
				max_proc*sizeof(proc_stat_t));
			assert(hold != NULL);
			proc_info = (proc_stat_t *)hold;
		}
	}
	if (errno != 0 && errno != ENOENT)
		log_err(errno, __func__, "readdir");

	sampletime_ceil = time_last_sample;
	return (PBSE_NONE);
}

/**
 * @brief
 *      Update the job attribute for resources used.
 *
 *      The first time this is called for a job, set up resource entries for
 *      each resource that can be reported for this machine.  Fill in the
 *      correct values.  Return an error code.
 *
 *      Assumes that the session ID attribute has already been set.
 *
 * @return int
 * @retval PBSE_NONE    for success.
 */
int 
mom_set_use(job *pjob)
{
	int			i;
	resource		*pres;
	resource		*pres_req;
	attribute		*at;
	attribute		*at_req;
	resource_def		*rd;
	u_Long 			*lp_sz, lnum_sz;
	long			 dur;
	unsigned long		*lp, lnum, oldcput;
	long                     ncpus_req;


	assert(pjob != NULL);
	at = &pjob->ji_wattr[(int)JOB_ATR_resc_used];
	assert(at->at_type == ATR_TYPE_RESC);

	if ((pjob->ji_qs.ji_svrflags & JOB_SVFLG_Suspend) != 0)
		return (PBSE_NONE);	/* job suspended, don't track it */

	DBPRT(("%s: entered %s\n", __func__, pjob->ji_qs.ji_jobid))

	at->at_flags |= ATR_VFLAG_MODIFY;
	if ((at->at_flags & ATR_VFLAG_SET) == 0) {
		attribute		*at2;
		unsigned long		usedcpus = 0;

		at->at_flags |= ATR_VFLAG_SET;

		rd = find_resc_def(svr_resc_def, "ncpus", svr_resc_size);
		assert(rd != NULL);

		at2 = &pjob->ji_wattr[(int)JOB_ATR_resource];
		if ((pres = find_resc_entry(at2, rd)) != NULL) {
			usedcpus = (ulong)pres->rs_value.at_val.at_long;

			for (i=0; i<num_pcpus; i++) {
				struct	bnode	*np = &node_array[i];
				struct	bproc_node_info_t	info;

				if (np->n_job != NULL)
					continue;
				if (bproc_nodeinfo(i, &info) != 0) {
					sprintf(log_buffer,
						"bproc_nodeinfo node %d", i);
					log_err(errno, __func__, log_buffer);
					continue;
				}
				if (pjob->ji_qs.ji_un.ji_momt.ji_exuid !=
					info.user)
					continue;
				if (pjob->ji_qs.ji_un.ji_momt.ji_exgid !=
					info.group)
					continue;

				DBPRT(("%s: alloc node %d\n", __func__, i))
				np->n_job = pjob;
			}
		}
		pres = add_resource_entry(at, rd);
		pres->rs_value.at_flags |= ATR_VFLAG_SET;
		pres->rs_value.at_type = ATR_TYPE_LONG;
		pres->rs_value.at_val.at_long = usedcpus;

		rd = find_resc_def(svr_resc_def, "cput", svr_resc_size);
		assert(rd != NULL);
		pres = add_resource_entry(at, rd);
		pres->rs_value.at_flags |= ATR_VFLAG_SET;
		pres->rs_value.at_type = ATR_TYPE_LONG;

		rd = find_resc_def(svr_resc_def, "cpupercent", svr_resc_size);
		assert(rd != NULL);
		pres = add_resource_entry(at, rd);
		pres->rs_value.at_flags |= ATR_VFLAG_SET;
		pres->rs_value.at_type = ATR_TYPE_LONG;
		pres->rs_value.at_val.at_long = 0;

		rd = find_resc_def(svr_resc_def, "vmem", svr_resc_size);
		assert(rd != NULL);
		pres = add_resource_entry(at, rd);
		pres->rs_value.at_flags |= ATR_VFLAG_SET;
		pres->rs_value.at_type = ATR_TYPE_SIZE;
		pres->rs_value.at_val.at_size.atsv_shift = 10;	/* KB */
		pres->rs_value.at_val.at_size.atsv_units = ATR_SV_BYTESZ;

		rd = find_resc_def(svr_resc_def, "walltime", svr_resc_size);
		assert(rd != NULL);
		pres = add_resource_entry(at, rd);
		pres->rs_value.at_flags |= ATR_VFLAG_SET;
		pres->rs_value.at_type = ATR_TYPE_LONG;

		rd = find_resc_def(svr_resc_def, "mem", svr_resc_size);
		assert(rd != NULL);
		pres = add_resource_entry(at, rd);
		pres->rs_value.at_flags |= ATR_VFLAG_SET;
		pres->rs_value.at_type = ATR_TYPE_SIZE;
		pres->rs_value.at_val.at_size.atsv_shift = 10;	/* KB */
		pres->rs_value.at_val.at_size.atsv_units = ATR_SV_BYTESZ;
	}

	rd = find_resc_def(svr_resc_def, "cput", svr_resc_size);
	assert(rd != NULL);
	pres = find_resc_entry(at, rd);
	assert(pres != NULL);
	lp = (unsigned long *)&pres->rs_value.at_val.at_long;
	oldcput = *lp;
	lnum = cput_sum(pjob);
	lnum = MAX(*lp, lnum);
	*lp = lnum;

	/* now calculate weight moving average cpu usage percentage */
	calc_cpupercent(pjob, oldcput, lnum, sampletime_ceil);
	pjob->ji_sampletim = sampletime_floor;

	rd = find_resc_def(svr_resc_def, "vmem", svr_resc_size);
	assert(rd != NULL);
	pres = find_resc_entry(at, rd);
	assert(pres != NULL);
	lp_sz = &pres->rs_value.at_val.at_size.atsv_num;
	lnum_sz = (mem_sum(pjob) + 1023) >> 10;	/* as KB */
	*lp_sz = MAX(*lp_sz, lnum_sz);

	rd = find_resc_def(svr_resc_def, "walltime", svr_resc_size);
	assert(rd != NULL);
	pres = find_resc_entry(at, rd);
	assert(pres != NULL);
	pres->rs_value.at_val.at_long = (long)((double)(time_now -
		pjob->ji_qs.ji_stime) * wallfactor);

	rd = find_resc_def(svr_resc_def, "mem", svr_resc_size);
	assert(rd != NULL);
	pres = find_resc_entry(at, rd);
	assert(pres != NULL);
	lp_sz = &pres->rs_value.at_val.at_size.atsv_num;
	lnum_sz = (resi_sum(pjob) + 1023) >> 10;	/* as KB */
	*lp_sz = MAX(*lp_sz, lnum_sz);

	return (PBSE_NONE);
}

/**
 * @brief
 *      bld_ptree - establish links (parent, child, and sibling) for processes
 *      in a given session.     
 *      
 *      The PBS_PROC_* macros are defined in resmom/.../mom_mach.h
 *      to refer to the correct machine dependent table.
 *              
 * @param[in] sid - session id
 *
 * @return      int
 * @retval      number of processes in session  Success
 *       
 */      
int
bld_ptree(pid_t sid)
{
	int	myproc_ct;	/* count of processes in a session */
	int	i, j;

	if (Proc_lnks == NULL) {
		Proc_lnks = (pbs_plinks *)malloc(TBL_INC * sizeof(pbs_plinks));
		assert(Proc_lnks != NULL);
		myproc_max = TBL_INC;
	}

	/*
	 * Build links for processes in the session in question.
	 * First, load with the processes in the session.
	 */

	myproc_ct = 0;
	for (i = 0; i < nproc; i++) {
		if (PBS_PROC_PID(i) <= 1)
			continue;
		if ((int)PBS_PROC_SID(i) == sid) {
			Proc_lnks[myproc_ct].pl_pid    = PBS_PROC_PID(i);
			Proc_lnks[myproc_ct].pl_ppid   = PBS_PROC_PPID(i);
			Proc_lnks[myproc_ct].pl_parent = -1;
			Proc_lnks[myproc_ct].pl_sib    = -1;
			Proc_lnks[myproc_ct].pl_child  = -1;
			Proc_lnks[myproc_ct].pl_done   = 0;
			if (++myproc_ct == myproc_max) {
				void * hold;

				myproc_max += TBL_INC;
				hold = realloc((void *)Proc_lnks,
					myproc_max*sizeof(pbs_plinks));
				assert(hold != NULL);
				Proc_lnks = (pbs_plinks *)hold;
			}
		}
	}

	/* Now build the tree for those processes */

	for (i = 0; i < myproc_ct; i++) {
		/*
		 * Find all the children for this process, establish links.
		 */
		for (j = 0; j < myproc_ct; j++) {
			if (j == i)
				continue;
			if (Proc_lnks[j].pl_ppid == Proc_lnks[i].pl_pid) {
				Proc_lnks[j].pl_parent = i;
				Proc_lnks[j].pl_sib = Proc_lnks[i].pl_child;
				Proc_lnks[i].pl_child = j;
			}
		}
	}
	return (myproc_ct);	/* number of processes in session */
}

/**
 * @brief
 *      kill_ptree - traverse the process tree, killing the processes as we go
 *
 * @param[in]   idx:    current pid index
 * @param[in]   flag:   traverse order, top down (1) or bottom up (0)
 * @param[in]   sig:    the signal to send
 *
 * @return      Void
 *
 */
static void
kill_ptree(int idx, int flag, int sig)
{
	pid_t	child;

	if (flag && !Proc_lnks[idx].pl_done) {		/* top down */
		(void)kill(Proc_lnks[idx].pl_pid, sig);
		Proc_lnks[idx].pl_done = 1;
	}
	child = Proc_lnks[idx].pl_child;
	while (child != -1) {
		kill_ptree(child, flag, sig);
		child = Proc_lnks[child].pl_sib;
	}
	if (!flag && !Proc_lnks[idx].pl_done) {		/* bottom up */
		(void)kill(Proc_lnks[idx].pl_pid, sig);
		Proc_lnks[idx].pl_done = 1;
	}
}

/**
 * @brief
 *      kill task session
 *
 * @param[in] ptask - pointer to pbs_task structure
 * @param[in] sig - signal number
 * @param[in] dir - indication how to kill
 *                  0 - kill child first
 *                  1 - kill parent first
 *
 * @return      int
 * @retval      number of tasks
 *
 */
int
kill_task(pbs_task *ptask, int sig, int dir)
{
	return kill_session(ptask->ti_qs.ti_sid, sig, dir);
}

/**
 * @brief
 *      Kill a task session.
 *      Call with the task pointer and a signal number.
 *      
 * @param[in] sesid - session id
 * @param[in] sig - signal number
 * @param[in] dir - indication how to kill
 *                  0 - kill child first
 *                  1 - kill parent first
 *
 * @return      int
 * @retval      number of tasks
 *
 */
int
kill_session(pid_t sesid, int sig, int dir)
{
	int		ct = 0;
	int		i;

	DBPRT(("%s: entered sid %d\n", __func__, sesid))
	if (sesid <= 1)
		return 0;

	(void)mom_get_sample();
	ct = bld_ptree(sesid);
	DBPRT(("%s: bld_ptree %d\n", __func__, ct))

	/*
	 ** Find index into the Proc_lnks table for the session lead.
	 */
	for (i = 0; i < ct; i++) {
		if (Proc_lnks[i].pl_pid == sesid) {
			kill_ptree(i, dir, sig);
			break;
		}
	}
	/*
	 ** If the session lead is gone, do a linear pass.
	 */
	for (i = 0; i < ct; i++) {
		if (Proc_lnks[i].pl_done)
			continue;
		DBPRT(("%s: cleanup %d\n", __func__, Proc_lnks[i].pl_pid))
		kill(Proc_lnks[i].pl_pid, sig);
	}

	return ct;
}

/**
 * @brief
 *      Clean up everything related to polling.
 *
 * @return      int
 * @retval      PBSE_NONE       Success
 * @retval      PBSE_SYSTEM     Error
 *
 */
int
mom_close_poll(void)
{
	DBPRT(("%s: entered\n", __func__))
	if (pdir) {
		if (closedir(pdir) != 0) {
			log_err(errno, __func__, "closedir");
			return (PBSE_SYSTEM);
		}
		pdir = NULL;
	}
	if (proc_info) {
		(void)free(proc_info);
		proc_info = NULL;
		max_proc = 0;
	}

	return (PBSE_NONE);
}

/**
 * @brief
 *      Checkpoint the job.
 *
 * @param[in] ptask - pointer to task
 * @param[in] file - filename
 * @param[in] abort - value indicating abort
 *
 * If abort is true, kill it too.
 *
 * @return      int
 * @retval      -1      error
 * @retval      0       success
 */
int
mach_checkpoint(task *ptask, char *file, int abort)
{
	return (-1);
}

/**
 * @brief
 *      Restart the job from the checkpoint file.
 *
 * @param[in] ptask - pointer to task
 * @param[in] file - filename
 *
 * @return      long
 * @retval      session id      Success
 * @retval      -1              Error
 */
long
mach_restart(task *ptask, char *file)
{
	return (-1);
}

/**
 * @brief
 *	Return 1 if proc table can be read, 0 otherwise.
 */
int
getprocs()
{
	static	unsigned	int	lastproc = 0;

	if (lastproc == reqnum)		/* don't need new proc table */
		return 1;

	if (mom_get_sample() != PBSE_NONE)
		return 0;

	lastproc = reqnum;
	return 1;
}

#define	dsecs(val) ((double)(val) )

/**
 * @brief
 *      computes and returns the cpu time process with  pid jobid
 *
 * @param[in] jobid - process id for job
 *
 * @return      string
 * @retval      cputime         Success
 * @retval      NULL            Error
 *
 */
char *
cput_job(pid_t jobid)
{
	int 			 i;
	int			 found = 0;
	double			 cputime, addtime;
	proc_stat_t		*ps;

	cputime = 0.0;
	for (i=0; i<nproc; i++) {

		ps = &proc_info[i];
		if (jobid !=  ps->session)
			continue;

		found = 1;
		addtime = dsecs(ps->cutime) + dsecs(ps->cstime);

		cputime += addtime;
		DBPRT(("%s: total %.2f pid %d %.2f\n", __func__, cputime,
			ps->pid, addtime))

	}
	if (found) {
		sprintf(ret_string, "%.2f", cputime * cputfactor);
		return ret_string;
	}

	rm_errno = RM_ERR_EXIST;
	return NULL;
}

/**
 * @brief
 *      computes and returns the cpu time process with  pid pid.
 *
 * @param[in] pid - process id
 *
 * @return      string
 * @retval      cputime         Success
 * @retval      NULL            Error
 *
 */
char *
cput_proc(pid_t pid)
{
	int			 i;
	double			 cputime;
	proc_stat_t		*ps;

	cputime = 0.0;

	mom_get_sample();
	for (i=0; i<nproc; i++) {
		ps = &proc_info[i];
		if (ps->pid == pid)
			break;
	}
	if (i == nproc) {
		rm_errno = RM_ERR_EXIST;
		return NULL;
	}
	cputime = dsecs(ps->utime) + dsecs(ps->stime);

	sprintf(ret_string, "%.2f", cputime * cputfactor);
	return ret_string;
}

/**
 * @brief
 *      wrapper function for cput_proc and cput_job.
 *
 * @param[in] attrib - pointer to rm_attribute structure
 *
 * @return      string
 * @retval      cputime         Success
 * @retval      NULL            ERRor
 *
 */
char *
cput(struct rm_attribute *attrib)
{
	int			value;

	if (attrib == NULL) {
		log_err(-1, __func__, no_parm);
		rm_errno = RM_ERR_NOPARAM;
		return NULL;
	}
	if ((value = atoi(attrib->a_value)) == 0) {
		sprintf(log_buffer, "bad param: %s", attrib->a_value);
		log_err(-1, __func__, log_buffer);
		rm_errno = RM_ERR_BADPARAM;
		return NULL;
	}
	if (momgetattr(NULL)) {
		log_err(-1, __func__, extra_parm);
		rm_errno = RM_ERR_BADPARAM;
		return NULL;
	}

	if (strcmp(attrib->a_qualifier, "session") == 0)
		return (cput_job((pid_t)value));
	else if (strcmp(attrib->a_qualifier, "proc") == 0)
		return (cput_proc((pid_t)value));
	else {
		rm_errno = RM_ERR_BADPARAM;
		return NULL;
	}
}

/**
 * @brief
 *      computes and returns the memory for session with  pid sid..
 *
 * @param[in] sid - process id
 *
 * @return      string
 * @retval      memsize         Success
 * @retval      NULL            Error
 *
 */
char *
mem_job(pid_t sid)
{
	ulong		 memsize;
	int		 i;
	proc_stat_t	*ps;

	memsize = 0;

	mom_get_sample();
	for (i=0; i<nproc; i++) {

		ps = &proc_info[i];

		if (sid != ps->session)
			continue;
		memsize += (ps->vsize >> 10);		/* KB */
	}

	if (memsize == 0) {
		rm_errno = RM_ERR_EXIST;
		return NULL;
	}
	else {
		sprintf(ret_string, "%lukb", memsize); /* KB */
		return ret_string;
	}
}

/**
 * @brief
 *      computes and returns the memory for process with  pid sid..
 *
 * @param[in] pid - process id
 *
 * @return      string
 * @retval      memsize         Success
 * @retval      NULL            Error
 *
 */
char *
mem_proc(pid_t pid)
{
	int		 i;
	proc_stat_t	*ps;

	mom_get_sample();
	for (i=0; i<nproc; i++) {
		ps  = &proc_info[i];
		if (ps->pid == pid)
			break;
	}
	if (i == nproc) {
		rm_errno = RM_ERR_SYSTEM;
		return NULL;
	}

	sprintf(ret_string, "%lukb", (ulong)ps->vsize >> 10); /* KB */
	return ret_string;
}

/**
 * @brief
 *      wrapper function for mem_job and mem_proc..
 *
 * @param[in] attrib - pointer to rm_attribute structure
 *
 * @return      string
 * @retval      memsize         Success
 * @retval      NULL            ERRor
 *
 */
char *
mem(struct rm_attribute *attrib)
{
	int			value;

	if (attrib == NULL) {
		log_err(-1, id, no_parm);
		rm_errno = RM_ERR_NOPARAM;
		return NULL;
	}
	if ((value = atoi(attrib->a_value)) == 0) {
		sprintf(log_buffer, "bad param: %s", attrib->a_value);
		log_err(-1, __func__, log_buffer);
		rm_errno = RM_ERR_BADPARAM;
		return NULL;
	}
	if (momgetattr(NULL)) {
		log_err(-1, __func__, extra_parm);
		rm_errno = RM_ERR_BADPARAM;
		return NULL;
	}

	if (strcmp(attrib->a_qualifier, "session") == 0)
		return (mem_job((pid_t)value));
	else if (strcmp(attrib->a_qualifier, "proc") == 0)
		return (mem_proc((pid_t)value));
	else {
		rm_errno = RM_ERR_BADPARAM;
		return NULL;
	}
}

/**
 * @brief
 *      computes and returns resident set size for job
 *
 * @param[in] jobid - pid for job
 *
 * @return      string
 * @retval      resident set size       Success
 * @retval      NULL                    Error
 *
 */
static char *
resi_job(pid_t jobid)
{
	int		 i;
	ulong		 resisize;
	int		 found = 0;
	proc_stat_t	*ps;

	resisize = 0;
	mom_get_sample();

	for (i=0; i<nproc; i++) {

		ps = &proc_info[i];

		if (jobid != ps->session)
			continue;

		found = 1;
		resisize += ps->rss;
	}
	if (found) {
		/* in KB */
		sprintf(ret_string, "%lukb",
			(ulong)(((double)resisize*(double)pagesize)/1024.0));
		return ret_string;
	}

	rm_errno = RM_ERR_EXIST;
	return NULL;
}

/**
 * @brief
 *      computes and returns resident set size for process
 *
 * @param[in] pid - process id
 *
 * @return      string
 * @retval      resident set size       Success
 * @retval      NULL                    Error
 *
 */
static char *
resi_proc(pid_t pid)
{
	int		 i;
	proc_stat_t	*ps;


	mom_get_sample();
	for (i=0; i<nproc; i++) {
		ps = &proc_info[i];
		if (ps->pid == pid)
			break;
	}
	if (i == nproc) {
		rm_errno = RM_ERR_EXIST;
		return NULL;
	}

	/* in KB */
	sprintf(ret_string, "%lukb", ((ulong)ps->rss * (ulong)pagesize) >> 10);
	return ret_string;
}

/**
 * @brief
 *      wrapper function for mem_job and mem_proc..
 *
 * @param[in] attrib - pointer to rm_attribute structure
 *
 * @return      string
 * @retval      resident set size       Success
 * @retval      NULL                    ERRor
 *
 */
static char *
resi(struct rm_attribute *attrib)
{
	int			value;

	if (attrib == NULL) {
		log_err(-1, __func__, no_parm);
		rm_errno = RM_ERR_NOPARAM;
		return NULL;
	}
	if ((value = atoi(attrib->a_value)) == 0) {
		sprintf(log_buffer, "bad param: %s", attrib->a_value);
		log_err(-1, __func__, log_buffer);
		rm_errno = RM_ERR_BADPARAM;
		return NULL;
	}
	if (momgetattr(NULL)) {
		log_err(-1, __func__, extra_parm);
		rm_errno = RM_ERR_BADPARAM;
		return NULL;
	}

	if (strcmp(attrib->a_qualifier, "session") == 0)
		return (resi_job((pid_t)value));
	else if (strcmp(attrib->a_qualifier, "proc") == 0)
		return (resi_proc((pid_t)value));
	else {
		rm_errno = RM_ERR_BADPARAM;
		return NULL;
	}
}

/**
 * @brief
 *      returns the number of sessions
 *
 * @param[in] attrib - pointer to rm_attribute structure
 *
 * @return      string
 * @retval      sessions        Success
 * @retval      NULL            error
 *
 */
char *
sessions(struct rm_attribute *attrib)
{
	char		*fmt;
	int		 i, j;
	proc_stat_t	*ps;
	int		 njids = 0;
	pid_t		*jids, *hold;
	static	int	 maxjid = 200;
	register	 pid_t	jobid;


	if (attrib) {
		log_err(-1, id, extra_parm);
		rm_errno = RM_ERR_BADPARAM;
		return NULL;
	}
	if ((jids = (pid_t *)calloc(maxjid, sizeof(pid_t))) == NULL) {
		log_err(errno, __func__, "no memory");
		rm_errno = RM_ERR_SYSTEM;
		return NULL;
	}

	mom_get_sample();

	/*
	 ** Search for members of session
	 */
	for (i=0; i<nproc; i++) {
		ps = &proc_info[i];

		if (ps->uid == 0)
			continue;
		if ((jobid = ps->session) == 0)
			continue;
		DBPRT(("%s[%d]: pid %d sid %d\n",
			__func__, njids, ps->pid, jobid))

		for (j=0; j<njids; j++) {
			if (jids[j] == jobid)
				break;
		}
		if (j == njids) {		/* not found */
			if (njids == maxjid) {	/* need more space */
				maxjid += 100;
				hold = (pid_t *)realloc(jids, maxjid);
				if (hold == NULL) {
					log_err(errno, __func__, "realloc");
					rm_errno = RM_ERR_SYSTEM;
					free(jids);
					return NULL;
				}
				jids = hold;
			}
			jids[njids++] = jobid;	/* add jobid to list */
		}
	}

	fmt = ret_string;
	for (j=0; j<njids; j++) {
		checkret(&fmt, 100);
		sprintf(fmt, " %d", (int)jids[j]);
		fmt += strlen(fmt);
	}
	free(jids);
	return ret_string;
}

/**
 * @brief
 *      wrapper function for sessions().
 *
 * @param[in] attrib - pointer to rm_attribute structure
 *
 * @return      string
 * @retval      sessions        Success
 * @retval      0               error
 *
 */
char *
nsessions(struct rm_attribute *attrib)
{
	char	*result, *ch;
	int	num = 0;

	if ((result = sessions(attrib)) == NULL)
		return result;

	for (ch=result; *ch; ch++) {
		if (*ch == ' ')		/* count blanks */
			num++;
	}
	sprintf(ret_string, "%d", num);
	return ret_string;
}

/**
 * @brief
 *      returns the number of processes in session
 *
 * @param[in] attrib - pointer to rm_attribute structure
 *
 * @return      string
 * @retval      process        Success
 * @retval      NULL            error
 *
 */
char *
pids(struct rm_attribute *attrib)
{
	char		*fmt;
	int		 i;
	pid_t		 jobid;
	proc_stat_t	*ps;
	int		num_pids;

	if (attrib == NULL) {
		log_err(-1, __func__, no_parm);
		rm_errno = RM_ERR_NOPARAM;
		return NULL;
	}
	if ((jobid = (pid_t)atoi(attrib->a_value)) == 0) {
		sprintf(log_buffer, "bad param: %s", attrib->a_value);
		log_err(-1, __func__, log_buffer);
		rm_errno = RM_ERR_BADPARAM;
		return NULL;
	}
	if (momgetattr(NULL)) {
		log_err(-1, __func__, extra_parm);
		rm_errno = RM_ERR_BADPARAM;
		return NULL;
	}

	if (strcmp(attrib->a_qualifier, "session") != 0) {
		rm_errno = RM_ERR_BADPARAM;
		return NULL;
	}

	mom_get_sample();

	/*
	 ** Search for members of session
	 */
	fmt = ret_string;
	num_pids = 0;

	for (i=0; i<nproc; i++) {

		ps = &proc_info[i];
		DBPRT(("%s[%d]: pid: %d sid %d\n",
			__func__, num_pids, ps->pid, ps->session))
		if (jobid != ps->session)
			continue;

		sprintf(fmt, "%d ", ps->pid);
		fmt += strlen(fmt);
		num_pids++;
	}
	if (num_pids == 0) {
		rm_errno = RM_ERR_EXIST;
		return NULL;
	}
	return ret_string;
}

/**
 * @brief
 *      returns the number of users
 *
 * @param[in] attrib - pointer to rm_attribute structure
 *
 * @return      string
 * @retval      users        Success
 * @retval      NULL            error
 *
 */
char *
nusers(struct rm_attribute *attrib)
{
	int			 i;
	int			 j;
	proc_stat_t		*ps;
	int			 nuids = 0;
	uid_t			*uids, *hold;
	static	int		 maxuid = 200;
	register uid_t		 uid;

	if (attrib) {
		log_err(-1, __func__, extra_parm);
		rm_errno = RM_ERR_BADPARAM;
		return NULL;
	}
	if ((uids = (uid_t *)calloc(maxuid, sizeof(uid_t))) == NULL) {
		log_err(errno, __func__, "no memory");
		rm_errno = RM_ERR_SYSTEM;
		return NULL;
	}

	mom_get_sample();
	for (i=0; i<nproc; i++) {
		ps = &proc_info[i];

		if ((uid = ps->uid) == 0)
			continue;

		DBPRT(("%s[%d]: pid %d uid %d\n",
			__func__, nuids, ps->pid, uid))

		for (j=0; j<nuids; j++) {
			if (uids[j] == uid)
				break;
		}
		if (j == nuids) {		/* not found */
			if (nuids == maxuid) {	/* need more space */
				maxuid += 100;
				hold = (uid_t *)realloc(uids, maxuid);
				if (hold == NULL) {
					log_err(errno, __func__, "realloc");
					rm_errno = RM_ERR_SYSTEM;
					free(uids);
					return NULL;
				}
				uids = hold;
			}
			uids[nuids++] = uid;	/* add uid to list */
		}
	}

	sprintf(ret_string, "%d", nuids);
	free(uids);
	return ret_string;
}

/**
 * @brief
 *      returns all the process ids
 *
 * @return      pid_t
 * @retval      pids    Success
 * @retval      NULl    Error
 *
 */
pid_t	*
allpids(void)
{
	int			 i;
	proc_stat_t		*ps;
	static	pid_t		*pids = NULL;

	getprocs();

	if (pids != NULL)
		free(pids);
	if ((pids = (pid_t *)calloc(nproc+1, sizeof(pid_t))) == NULL) {
		log_err(errno, __func__, "no memory");
		return NULL;
	}

	for (i=0; i<nproc; i++) {
		ps = &proc_info[i];

		pids[i] = ps->pid;	/* add pid to list */
	}
	pids[nproc] = -1;
	return pids;
}

/**
 * @brief
 *       return amount of total memory on system in KB as numeric string
 *    
 * @return      string
 * @retval      total memory            Success
 * @retval      NULl                    Error
 *
 */
static char *
totmem(struct rm_attribute *attrib)
{
	proc_mem_t	*mm;

	if (attrib) {
		log_err(-1, __func__, extra_parm);
		rm_errno = RM_ERR_BADPARAM;
		return NULL;
	}

	if ((mm = get_proc_mem()) == NULL) {
		log_err(errno, __func__, "get_proc_mem");
		rm_errno = RM_ERR_SYSTEM;
		return NULL;
	}
	DBPRT(("%s: total mem=%u\n", __func__, mm->total))
	sprintf(ret_string, "%lukb", (ulong)mm->total >> 10); /* KB */
	return ret_string;
}

/**
 * @brief
 *      returns available free process memory
 *
 * @return      string
 * @retval      avbl free process memory                Success
 * @retval      NULl                                    Error
 *
 */
static char	*
availmem(struct rm_attribute *attrib)
{
	proc_mem_t	*mm;

	if (attrib) {
		log_err(-1, __func__, extra_parm);
		rm_errno = RM_ERR_BADPARAM;
		return NULL;
	}

	if ((mm = get_proc_mem()) == NULL) {
		log_err(errno, __func__, "get_proc_mem");
		rm_errno = RM_ERR_SYSTEM;
		return NULL;
	}
	DBPRT(("%s: free mem=%u\n", __func__, mm->free))
	sprintf(ret_string, "%lukb", (ulong)mm->free >> 10); /* KB */
	return ret_string;
}

/**
 * @brief
 *      return the number of cpus
 *
 * @param[in] attrib - pointer to rm_attribute structure
 *
 * @return      string
 * @retval      number of cpus  Success
 * @retval      NULL            Error
 *
 */
static char *
ncpus(struct rm_attribute *attrib)
{
	extern	int	internal_state;
	extern	int	internal_state_update;
	int		i, nodeup;
#ifdef	BEOSTAT_COMPAT
	struct	beostat_meminfo	minfo;
#else
	struct	meminfo		minfo;
#endif

	if (attrib) {
		log_err(-1, __func__, extra_parm);
		rm_errno = RM_ERR_BADPARAM;
		return NULL;
	}

	num_acpus = 0;
	for (i=0; i<num_pcpus; i++) {
		struct	bnode	*np = &node_array[i];

		nodeup = (bproc_nodestatus(i) == bproc_node_up);

		if (!nodeup) {			/* is down */
			if (np->n_up) {		/* was up */
				internal_state_update = UPDATE_MOM_STATE;
				sprintf(log_buffer, "node %d marked DOWN", i);
				log_event(PBSEVENT_SYSTEM,
					PBS_EVENTCLASS_SERVER, LOG_INFO,
					__func__, log_buffer);

				np->n_up = 0;
				np->n_mem = 0;
			}
			continue;
		}

		if (nodeup && !np->n_up) {	/* came up */
			internal_state_update = UPDATE_MOM_STATE;
			sprintf(log_buffer, "node %d marked UP", i);
			log_event(PBSEVENT_SYSTEM, PBS_EVENTCLASS_SERVER,
				LOG_INFO, __func__, log_buffer);

			beostat_cpu_count(i, &np->n_cpus);
			np->n_up = 1;

			if (beostat_meminfo(i, &minfo) != -1) {
				np->n_mem = (minfo.mem.used +
					minfo.mem.free) >> 10;
			}
		}
		num_acpus += np->n_cpus;
	}

	sprintf(ret_string, "%d", num_acpus);
	return ret_string;
}

/**
 * @brief
 *      returns the total physical memory
 *      
 * @param[in] attrib - pointer to rm_attribute structure
 *      
 * @return      string
 * @retval      tot physical memory     Success
 * @retval      NULL                    Error
 *              
 */             
char *
physmem(struct rm_attribute *attrib)
{
	struct	stat	buf;
	ulong		size = 0;
	int		i;

	if (attrib) {
		log_err(-1, __func__, extra_parm);
		rm_errno = RM_ERR_BADPARAM;
		return NULL;
	}

	/* add up nodes memory */
	for (i=0; i<num_pcpus; i++) {
		struct	bnode	*np = &node_array[i];

		if (!np->n_up)
			continue;

		size += np->n_mem;
		DBPRT(("%s: node %d %ukb\n", __func__, i, size))
	}
	sprintf(ret_string, "%lukb", size);
	return ret_string;
}

/**
 * @brief
 *      returns the size of file system present in machine
 *
 * @param[in] param - attribute value(file system)
 *
 * @return      string
 * @retval      size of file system     Success
 * @retval      NULL                    Error
 *
 */
char *
size_fs(char *param)
{
	struct	statfs	fsbuf;

	if (param[0] != '/') {
		sprintf(log_buffer, "%s: not full path filesystem name: %s",
			__func__, param);
		log_err(-1, __func__, log_buffer);
		rm_errno = RM_ERR_BADPARAM;
		return NULL;
	}
	if (statfs(param, &fsbuf) == -1) {
		log_err(errno, __func__, "statfs");
		rm_errno = RM_ERR_BADPARAM;
		return NULL;
	}
	sprintf(ret_string, "%lukb",
		(ulong)(((double)fsbuf.f_bsize *
		(double)fsbuf.f_bfree) / 1024.0)); /* KB */
	return ret_string;
}

/**
 * @brief
 *      get file attribute(size) from param and put them in buffer.
 *
 * @param[in] param - file attributes
 *
 * @return      string
 * @retval      size of file    Success
 * @retval      NULL            Error
 *
 */
char *
size_file(char *param)
{
	struct	stat	sbuf;

	if (param[0] != '/') {
		sprintf(log_buffer, "%s: not full path filesystem name: %s",
			__func__, param);
		log_err(-1, __func__, log_buffer);
		rm_errno = RM_ERR_BADPARAM;
		return NULL;
	}

	if (stat(param, &sbuf) == -1) {
		log_err(errno, __func__, "stat");
		rm_errno = RM_ERR_BADPARAM;
		return NULL;
	}

	sprintf(ret_string, "%lukb", sbuf.st_size >> 10); /* KB */
	return ret_string;
}

/**
 * @brief
 *      wrapper function for size_file which returns the size of file system
 *
 * @param[in] attrib - pointer to rm_attribute structure
 *
 * @return      string
 * @retval      size of file system     Success
 * @retval      NULL                    Error
 *
 */
char *
size(struct rm_attribute *attrib)
{
	char		*param;

	if (attrib == NULL) {
		log_err(-1, __func__, no_parm);
		rm_errno = RM_ERR_NOPARAM;
		return NULL;
	}
	if (momgetattr(NULL)) {
		log_err(-1, __func__, extra_parm);
		rm_errno = RM_ERR_BADPARAM;
		return NULL;
	}

	param = attrib->a_value;
	if (strcmp(attrib->a_qualifier, "file") == 0)
		return (size_file(param));
	else if (strcmp(attrib->a_qualifier, "fs") == 0)
		return (size_fs(param));
	else {
		rm_errno = RM_ERR_BADPARAM;
		return NULL;
	}
}

/**
 * @brief
 *      computes and returns walltime for process or session.
 *
 * @param[in] attrib - pointer to rm_attribute structure
 *
 * @return      string
 * @retval      walltime        Success
 * @retval      NULL            Error
 *
 */
static char *
walltime(struct rm_attribute *attrib)
{
	int		 i;
	int		 value, job, found = 0;
	time_t		 now, start;
	proc_stat_t	*ps;

	if (attrib == NULL) {
		log_err(-1, __func__, no_parm);
		rm_errno = RM_ERR_NOPARAM;
		return NULL;
	}
	if ((value = atoi(attrib->a_value)) == 0) {
		sprintf(log_buffer, "bad param: %s", attrib->a_value);
		log_err(-1, __func__, log_buffer);
		rm_errno = RM_ERR_BADPARAM;
		return NULL;
	}
	if (momgetattr(NULL)) {
		log_err(-1, __func__, extra_parm);
		rm_errno = RM_ERR_BADPARAM;
		return NULL;
	}

	if (strcmp(attrib->a_qualifier, "proc") == 0)
		job = 0;
	else if (strcmp(attrib->a_qualifier, "session") == 0)
		job = 1;
	else {
		rm_errno = RM_ERR_BADPARAM;
		return NULL;
	}

	if ((now = time(NULL)) <= 0) {
		log_err(errno, __func__, "time");
		rm_errno = RM_ERR_SYSTEM;
		return NULL;
	}
	mom_get_sample();

	start = now;
	for (i=0; i<nproc; i++) {
		ps = &proc_info[i];

		if (job) {
			if (value != ps->session)
				continue;
		}
		else {
			if (value != ps->pid)
				continue;
		}

		found = 1;
		start = MIN(start, ps->start_time);
	}

	if (found) {
		sprintf(ret_string, "%ld",
			(long)((double)(now - start) * wallfactor));
		return ret_string;
	}

	rm_errno = RM_ERR_EXIST;
	return NULL;
}

/**
 * @brief
 *      reads load avg from file and returns
 *
 * @param[out] rv - var to hold load avg
 *
 * @return      int
 * @retval      0                       Success
 * @retval      RM_ERR_SYSTEM(15205)    error
 *
 */
int
get_la(double *rv)
{
	FILE	*fp;
	float	load;

	if ((fp = fopen("/proc/loadavg", "r")) == NULL)
		return (rm_errno = RM_ERR_SYSTEM);

	if (fscanf(fp, "%f", &load) != 1) {
		log_err(errno, __func__, "fscanf of load in /proc/loadavg");
		(void) fclose(fp);
		return (rm_errno = RM_ERR_SYSTEM);
	}

	*rv = (double)load;
	(void) fclose(fp);
	return 0;
}

/**
 * @brief
 *      computes and returns the gracetime
 *
 * @param[in] secs - time
 *
 * @return      u_long
 * @retval      time in secs    if time limit > 0
 * @retval      0               if time limit < 0
 */
u_long
gracetime(u_long secs)
{
	time_t	now = time((time_t *)NULL);

	if (secs > now)		/* time is in the future */
		return (secs - now);
	else
		return 0;
}

/**
 * @brief
 *      set priority of processes.
 *
 * @return      Void
 *
 */
void
mom_nice()
{
	if ((nice_val != 0) && (setpriority(PRIO_PROCESS, 0, nice_val) == -1)) {
		(void)sprintf(log_buffer, "failed to nice(%d) mom", nice_val);
		log_err(errno, __func__, log_buffer);
	}
}

/**
 * @brief
 *      Unset priority of processes.
 *
 * @return      Void
 *
 */
void
mom_unnice()
{
	if ((nice_val != 0) && (setpriority(PRIO_PROCESS, 0, 0) == -1)) {
		(void)sprintf(log_buffer, "failed to nice(%d) mom", nice_val);
		log_err(errno, __func__, log_buffer);
	}
}

/**
 * @brief
 *      Get the info required for tm_attach.
 *
 * @param[in] pid - process id
 * @param[in] sid - session id
 * @param[in] uid - user id
 * @param[in] comm - command name
 * @param[in] len - size of command
 *
 * @return      int
 * @retval      TM_OKAY                 Success
 * @retval      TM_ENOPROC(17011)       Error
 *
 */
int
dep_procinfo(pid_t pid, pid_t *sid, uid_t *uid, char *comm, size_t len)
{
	int		 i;
	proc_stat_t	*ps;

	getprocs();

	for (i=0; i<nproc; i++) {
		ps  = &proc_info[i];

		if (ps->pid == pid) {
			*sid = ps->session;
			*uid = ps->uid;
			memset(comm, '\0', len);
			memcpy(comm, ps->comm,
				MIN(len-1, sizeof(ps->comm)));
			return TM_OKAY;
		}
	}
	return TM_ENOPROC;
}

/**
 * @brief
 *      No special attach functionality is required.
 *
 * @retturn     int
 * @retval      TM_OKAY
 *
 */
int
dep_attach(task *ptask)
{
	return TM_OKAY;
}

