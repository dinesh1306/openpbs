/*
 * Copyright (C) 1994-2018 Altair Engineering, Inc.
 * For more information, contact Altair at www.altair.com.
 *
 * This file is part of the PBS Professional("PBS Pro") software.
 *
 * Open Source License Information:
 *
 * PBS Pro is free software. You can redistribute it and/or modify it under the
 * terms of the GNU Affero General Public License as published by the Free
 * Software Foundation, either version 3 of the License, or (at your option) any
 * later version.
 *
 * PBS Pro is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.
 * See the GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Commercial License Information:
 *
 * For a copy of the commercial license terms and conditions,
 * go to: (http://www.pbspro.com/UserArea/agreement.html)
 * or contact the Altair Legal Department.
 *
 * Altair’s dual-license business model allows companies, individuals, and
 * organizations to create proprietary derivative works of PBS Pro and
 * distribute them - whether embedded or bundled with other software -
 * under a commercial license agreement.
 *
 * Use of Altair’s trademarks, including but not limited to "PBS™",
 * "PBS Professional®", and "PBS Pro™" and Altair’s logos is subject to Altair's
 * trademark licensing policies.
 *
 */

#include <pbs_config.h>   /* the master config generated by configure */
/**
 * @file	pbs_hpcp_client.c
 */
#include <stdio.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <openssl/ssl.h>
#include <openssl/bio.h>
#include <openssl/err.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdlib.h>
#include <signal.h>
#include <dlfcn.h>
#include <netdb.h>

#include "wsseapi.h"
#include "BESFactoryBinding.nsmap"
#include "pbs_hpcp_client.h"
#include "placementsets.h"
#include "log.h"
#include "pbs_assert.h"
#include "job.h"
#include "resource.h"
#include "mom_func.h"
#include "pbs_nodes.h"
#include "svrfunc.h"
#include "Long.h"
#include "ticket.h"

/* Default HPC Basic Profile Server Port number */
#define HPCBP_SERVER_PORT	"443"
#define HPCBP_NODE_FILE		"nodes.xml"
#define	HPCBP_JOBID		"(HPCBP_JOBID)"

/* HPCBP STAGING flags */

#define HPCBP_JOB_STAGE_IN		1
#define HPCBP_JOB_STAGE_OUT		2
#define HPCBP_JOB_STAGE_STDOUT		3

static char CREATE_ACTION[] 	=
	"http://schemas.ggf.org/bes/2006/08/bes-factory/"
"BESFactoryPortType/CreateActivity";
static char STATUS_ACTION[] 	=
	"http://schemas.ggf.org/bes/2006/08/bes-factory/"
"BESFactoryPortType/GetActivityStatuses";
static char TERMINATE_ACTION[] 	=
	"http://schemas.ggf.org/bes/2006/08/bes-factory/"
"BESFactoryPortType/TerminateActivities";
static char FACTORY_ACTION[] 	=
	"http://schemas.ggf.org/bes/2006/08/bes-factory/"
"BESFactoryPortType/GetFactoryAttributesDocument";

static char WSA_NS[] = "http://www.w3.org/2005/08/addressing";
static char BES_NS[] = "http://schemas.ggf.org/bes/2006/08/bes-factory";

/* JSDL Element names */

static char JOB_DEFINITION[] 	= 	"jsdl:JobDefinition";
static char JSDL_SCHEMA[] 	=
	"http://schemas.ggf.org/jsdl/2005/11/jsdl";
static char JSDL_HPCPA_SCHEMA[] =
	"http://schemas.ggf.org/jsdl/2006/07/jsdl-hpcpa";
static char CREDENTIAL_SCHEMA[] =
	"http://docs.oasis-open.org/wss/2004/01/"
"oasis-200401-wss-wssecurity-secext-1.0.xsd";
static char XSI_SCHEMA[]	=
	"http://www.w3.org/2001/XMLSchema-instance";
static char WSA_ENDPOINT[]	=	"wsa:EndpointReference";
static char WSA_SCHEMA[]	=	"http://www.w3.org/2005/08/addressing";
static char WSA_ADDRESS[]	=	"wsa:Address";
static char JOB_DESCRIPTION[]	= 	"jsdl:JobDescription";
static char JOB_IDENT[]		=	"jsdl:JobIdentification";
static char JOB_NAME[]		= 	"jsdl:JobName";
static char JOB_PROJECT[]	=	"jsdl:JobProject";
static char APPLICATION[] 	=	"jsdl:Application";
static char HPCPA_APPLICATION[]	= 	"jsdl-hpcpa:HPCProfileApplication";
static char HPCPA_EXECUTABLE[] 	=	"jsdl-hpcpa:Executable";
static char HPCPA_ENVIRONMENT[]	=	"jsdl-hpcpa:Environment";
static char HPCPA_OUTPUT[]	=	"jsdl-hpcpa:Output";
static char HPCPA_ERROR[]	=	"jsdl-hpcpa:Error";
static char RESOURCES[]		=	"jsdl:Resources";
static char CANDIDATE_HOSTS[]	= 	"jsdl:CandidateHosts";
static char JOB_HOSTNAME[]	=	"jsdl:HostName";
static char OPERATING_SYSTEM[] 	=	"jsdl:OperatingSystem";
static char OS_TYPE[] 		= 	"jsdl:OperatingSystemType";
static char OS_NAME[] 		= 	"jsdl:OperatingSystemName";
static char OS_VERSION[]	=	"jsdl:OperatingSystemVersion";
static char TOTAL_CPU_COUNT[]	= 	"jsdl:TotalCPUCount";
static char UPPER_BOUND_RANGE[] =	"jsdl:UpperBoundedRange";
static char LOWER_BOUND_RANGE[] = 	"jsdl:LowerBoundedRange";
static char DATA_STAGING[]	=	"jsdl:DataStaging";
static char FILE_NAME[]		=	"jsdl:FileName";
static char CREATION_FLAG[]	=	"jsdl:CreationFlag";
static char DEL_ON_TERMINATE[]	=	"jsdl:DeleteOnTermination";
static char SOURCE[]		=	"jsdl:Source";
static char URI[]		=	"jsdl:URI";
static char TARGET[]		=	"jsdl:Target";
static char CREDENTIAL[]	=	"jsdl:Credential";
static char USERNAME_TOKEN[]	=	"jsdl:UsernameToken";
static char USERNAME[]		=	"jsdl:Username";
static char PASSWORD[]		=	"jsdl:Password";
static char TOTAL_CPU_TIME[]	=	"jsdl:TotalCPUTime";
static char TOTAL_MEM[]		=	"jsdl:TotalPhysicalMemory";
static char IND_CPU_TIME[]	=	"jsdl:IndividualCPUTime";
static char IND_PHY_MEM[]	=	"jsdl:IndividualPhysicalMemory";
static char IND_DISK_SPACE[]	=	"jsdl:IndivisualDiskSpace";
static char IND_VIRTUAL_MEM[]	=	"jsdl:IndividualVirtualMemory";

/* HPC Advanced Filter Specification elements */
static char AF_ELEMENT[]	=	"hpcp-af:AdvancedFilter";
static char AF_SCHEMA[]		=
	"http://schemas.ogf.org/hpcp/2007/11/bp/AdvancedFilter";
static char AF_NODESTATUS[]	=	"hpcp-af:NodeStatus";
static char AF_ACTIVITYID[]	=	"hpcp-af:ActivityId";

/* HPCBP MOM log messages */
static char HPCBP_SSL_CNT_ERR[] =
	"unable to create SSL-based channel to connect to the Web Service endpoint";
static char HPCBP_USER_ERR[]	=
	"unable to add username/password to the SOAP message";
static char HPCBP_OPENSSL_ERR[] =
	"unable to find openSSL libraries on the system";
static char HPCBP_CNT_ERR[]	=
	"unable to connect to hpcbp web service endpoint";
static char HPCBP_CERT_CREATE[]	=
	"unable to create HPCBP Server certificate";
static char HPCBP_CERT_WRITE[]	=
	"unable to write HPCBP Server certificate to a file";
static char HPCBP_END_ERR[]	=
	"unable to create End point reference file";
static char HPCBP_SHELL_WARN[]	=	"ignored: Shell_Path_List";
static char HPCBP_GRP_WARN[]	=	"ignored: group_list";
static char HPCBP_MASK_WARN[]	=	"ignored: umask";
static char HPCBP_JSDL_ERR[]	=	"unable to create JSDL document";
static char HPCBP_NICE_WARN[]	=	"ignored: nice";
static char HPCBP_GSOAP_INIT[]	=
	"unable to initialize gSOAP runtime environment";
static char HPCBP_HEAD_QSUB[]	=
	"unable to add SOAP header to the 'createactivity' request message";
static char HPCBP_HEAD_QSTAT[]	=
	"unable to add SOAP header to the 'getactivitystatuses' request message";
static char HPCBP_HEAD_QDEL[]	=
	"unable to add SOAP header to the 'terminateactivities' request message";
static char HPCBP_HEAD_NODES[]	=
	"unable to add SOAP header to the"
" 'getfactoryattributesdocument' request message";
static char HPCBP_JSDL_OPEN[]	=	"unable to open JSDL document";
static char HPCBP_JSDL_READ[]	=
	"error in reading contents of the JSDL document";
static char HPCBP_QSUB_CRED[]	=
	"unable to submit job with user's credential";
static char HPCBP_READ_ACT[]	=
	"unable to read hpcbp job identifier from createactivity response";
static char HPCBP_CRT_ACT[]	=	"unable to create activity identifier";
static char HPCBP_READ_ID[]	=	"unable to read  hpcbp job identifier";
static char HPCBP_READ_QDEL_RES[] =
	"unable to parse the response received for"
" job deletion request from HPCBP Server";
static char HPCBP_QDEL_CRED[]	=
	"unable to terminate job with user's credentials";
static char HPCBP_READ_QSTAT_RES[] =
	"unable to parse the job status response received from HPCBP Server";
static char HPCBP_MEM_ALLOC[]	=	 "unable to allocate memory";
static char HPCBP_CNT_RES[]	=
	"unable to parse portion of HPCBP webservice address";
static char HPCBP_INVALID_ARG[] =	"Invalid argument";
static char HPCBP_CNT_SSL[]	= 	"unable to establish SSL context";
static char HPCBP_CNT_CONNECT[]	=	"unable to setup connection";
static char HPCBP_FETCH_CERT[]	=
	"unable to fetch HPCBP Server certificate";
static char HPCBP_DECRYPT_ERR[]	=
	"unable to decrypt user's credential";
static char HPCBP_WRITE_ACT[]	=
	"unable to write activity identifier to the file";
static char HPCBP_FILE_CONT[]	=	"unable to populate contents of file";
static char HPCBP_JSDL_SCRIPT[]	=	"unable to create JSDL document";
static char HPCBP_NODES_XML[]	=	"unable to create nodes.xml file";
static char HPCBP_PBS_INVALID[]	=	"Invalid option to hpcbp_pbs_pbsnodes";

/* HPCBP Job Requests   */
enum hpcbp_req_t {
	HPCBP_REQUEST_PBSNODES,
	HPCBP_REQUEST_QSTAT,
	HPCBP_REQUEST_QDEL,
	HPCBP_REQUEST_QSUB
};

/* Global data items for storing the node attributes */

extern vnl_t 	*vnlp;
extern char 	*hpcbp_certificate_path;
extern char	*hpcbp_user_name;
extern char 	*hpcbp_webservice_address;
extern char	*hpcbp_user_credbuf;
extern size_t	hpcbp_user_credlen;
extern char 	*hpcbp_stage_protocol;
extern char 	*hpcbp_endpoint_reference;
static char	**hpcbp_vnodes = NULL;
extern int	hpcbp_ompthreads;
static char	*hpcbp_protocol = NULL;
static int	hpcbp_protocol_flag = 0;
static char	*hpcbp_port = NULL;

static struct Namespace default_namespaces[] =
	{
	{"SOAP-ENV", "http://schemas.xmlsoap.org/soap/envelope/",
		"http://www.w3.org/*/soap-envelope", NULL},
	{"wsse", "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd", NULL, NULL},
	{"wsa", "http://www.w3.org/2005/08/addressing", NULL, NULL},
	{"bes", "http://schemas.ggf.org/bes/2006/08/bes-factory", NULL, NULL},
	{"jsdl", "http://schemas.ggf.org/jsdl/2005/11/jsdl", NULL, NULL},
	{"jsdl-hpcpa", "http://schemas.ggf.org/jsdl/2006/07/jsdl-hpcpa", NULL, NULL},
	{"hpcp-af", "http://schemas.ogf.org/hpcp/2007/11/bp/AdvancedFilter",
		NULL, NULL},
	{"jsdl-posix", "http://schemas.ggf.org/jsdl/2005/11/jsdl-posix", NULL, NULL},
	{NULL, NULL, NULL, NULL}
};

static struct Namespace epr_namespaces[] = {
	{"wsa", WSA_NS, NULL, NULL },
	{"bes", BES_NS, NULL, NULL },
	{"xsi", "http://www.w3.org/2001/XMLSchema-instance",
		"http://www.w3.org/*/XMLSchema-instance", NULL},
	{NULL, NULL, NULL, NULL}
};

/*
 * hpcbp_arch structure store values of OperaingSystemName,
 * and OperatingSystemVersion based on 'arch'
 */

struct hpcbp_arch {
	char *arch_value;
	char *arch_osname;
	char *arch_osversion;
};

/* Declaration holding all values of hpcbp_arch */

static struct hpcbp_arch arch_values[] = {
	{ "aix4", "AIX", NULL},
	{ "hpux10", "HPUX", NULL},
	{ "hpux11", "HPUX", NULL},
	{ "irix6", "IRIX", NULL},
	{ "linux", "LINUX", NULL},
	{ "solaris7", "Solaris", NULL},
	{ "Digitalunix", "Tru64 UNIX", NULL},
	{ "Windows_2003_Server", "other", "Windows_2003_Server"},
	{ "Windows_2008_Server", "other", "Windows_2008_Server"},
	{ "other", "other", NULL},
	{ "macos", "MACOS", NULL},
	{ "attunix", "ATTUNIX", NULL},
	{ "dgux", "DGUX", NULL},
	{ "decnt", "DECNT", NULL},
	{ "OpenMVS", "OpenMVS", NULL},
	{ "MVS", "MVS", NULL},
	{ "OS400", "OS400", NULL},
	{ "OS_2", "OS_2", NULL},
	{ "JavaVM", "JavaVM", NULL},
	{ "WINNT", "WINNT", NULL},
	{ "WINCE", "WINCE", NULL},
	{ "NCR3000", "NCR3000", NULL},
	{ "NetWare", "NetWare", NULL},
	{ "OSF", "OSF", NULL},
	{ "DC_OS", "DC_OS", NULL},
	{ "Reliant_UNIX", "Reliant_UNIX", NULL},
	{ "SCO_UnixWare", "SCO_UnixWare", NULL},
	{ "SCO_OpenServer", "SCO_OpenServer", NULL},
	{ "Sequent", "Sequent", NULL},
	{ "SunOS", "SunOS", NULL},
	{ "U6000", "U6000", NULL},
	{ "ASERIES", "ASERIES", NULL},
	{ "TandemNSK", "TandemNSK", NULL},
	{ "TandemNT", "TandemNT", NULL},
	{ "BS2000", "BS2000", NULL},
	{ "Lynx", "Lynx", NULL},
	{ "XENIX", "XENIX", NULL},
	{ "VM", "VM", NULL},
	{ "Interactive_UNIX", "Interactive_UNIX", NULL},
	{ "BSDUNIX", "BSDUNIX", NULL},
	{ "FreeBSD", "FreeBSD", NULL},
	{ "NetBSD", "NetBSD", NULL},
	{ "GNU_Hurd", "GNU_Hurd", NULL},
	{ "OS9", "OS9", NULL},
	{ "MACH_Kernel", "MACH_Kernel", NULL},
	{ "Inferno", "Inferno", NULL},
	{ "QNX", "QNX", NULL},
	{ "EPOC", "EPOC", NULL},
	{ "IxWorks", "IxWorks", NULL},
	{ "VxWorks", "VxWorks", NULL},
	{ "MiNT", "MiNT", NULL},
	{ "BeOS", "BeOS", NULL},
	{ "HP_MPE", "HP_MPE", NULL},
	{ "NextStep", "NextStep", NULL},
	{ "PalmPilot", "PalmPilot", NULL},
	{ "Rhapsody", "Rhapsody", NULL},
	{ "Windows_2000", "Windows_2000", NULL},
	{ "Dedicated", "Dedicated", NULL},
	{ "OS_390", "OS_390", NULL},
	{ "VSE", "VSE", NULL},
	{ "TPF", "TPF", NULL},
	{ "Windows_R_Me", "Windows_R_Me", NULL},
	{ "Caldera_Open_UNIX", "Caldera_Open_UNIX", NULL},
	{ "OpenBSD", "OpenBSD", NULL},
	{ "Not_Applicable", "Not_Applicable", NULL},
	{ "Windows_XP", "Windows_XP", NULL},
	{ "z_OS", "z_OS", NULL}
};


static char *hpcbp_status2state[] = { "Pending",  "Running",
	"Finished", "Terminated", "Failed", "Unknown"
};


/*
 * hpcbp_soap_uninit method is used to uninitialize
 * and detach memory allocated for gSOAP run-time environment
 */

static void
hpcbp_soap_uninit(struct soap *soap)
{
	if (soap == NULL)
		return;
	if (soap != NULL) {
		soap_end(soap);
		soap_done(soap);
		soap_free(soap);
	}
}

/*
 * hpcbp_parse_stage_protocol method reads hpcbp_stage_protocol and parses
 * into two different parts: protocol-name and port-number.
 * If 'hpcbp_stage_protocol' contains ':' then it sets hpcbp_protocol_flag
 * to 1.
 * Returns 0 on Success and -1 on failure.
 */

static int
hpcbp_parse_stage_protocol()
{
	static char 	id[] = "hpcbp_parse_stage_protocol";
	char		*tmp = NULL;
	int		ind;

	tmp = strchr(hpcbp_stage_protocol, ':');
	if (tmp == NULL) {
		/* ':' character not found */
		hpcbp_protocol = strdup(hpcbp_stage_protocol);
		if (hpcbp_protocol == NULL) {
			sprintf(log_buffer, HPCBP_MEM_ALLOC);
			log_err(LOG_ERR, id, log_buffer);
			return (-1);
		}
		DBPRT(("%s: hpcbp_protocol: %s\n", id, hpcbp_protocol))
	} else {
		ind = tmp - hpcbp_stage_protocol;
		/* found index */
		hpcbp_protocol = malloc(ind + 1);
		if (hpcbp_protocol == NULL) {
			sprintf(log_buffer, HPCBP_MEM_ALLOC);
			log_err(LOG_ERR, id, log_buffer);
			return (-1);
		}
		strncpy(hpcbp_protocol, hpcbp_stage_protocol, ind);
		hpcbp_protocol[ind] = '\0';
		DBPRT(("%s: hpcbp_protocol: %s\n", id, hpcbp_protocol))

		/* Store port number to 'hpcbp_port' */
		tmp++;
		if (hpcbp_port) { /* free previously allocated memory */
			free(hpcbp_port);
			hpcbp_port = NULL;
		}
		hpcbp_port = strdup(tmp);
		if (hpcbp_port == NULL) {
			sprintf(log_buffer, HPCBP_MEM_ALLOC);
			log_err(LOG_ERR, id, log_buffer);
			free(hpcbp_protocol);
			hpcbp_protocol = NULL;
			return -1;
		}
		DBPRT(("%s: hpcbp_port: %s\n", id, hpcbp_port))
		hpcbp_protocol_flag = 1;
	}
	return 0;
}




/*
 * hpcbp_soap_init creates a gSOAP run-time environment to access the
 * HPCBP web service end point. It takes user_name, password and
 * pointer to an address of soap struct and returns 0 upon sucessful
 * creation of gSOAP object. Otherwise, it returns -1 for failure.
 */

static int
hpcbp_soap_init(char *user_name, char *password, struct soap  **s)
{
	static char id[] = "hpcbp_soap_init";

	/* Initialize gSOAP */
	soap_ssl_init();
	*s = soap_new1(SOAP_DOM_TREE|SOAP_C_UTFSTRING);
	if (*s == NULL)
		return -1;
	soap_set_mode(*s, SOAP_C_UTFSTRING);
	/*
	 * Register with WSSE module to pass username
	 * password to HPCBP Web service end point
	 * WSSE is a specification from OASIS, which decribes
	 * how a web service consumer can supply a UsernameToken
	 * as a means of identifying/authenticating requestor
	 */
	if (soap_register_plugin(*s, soap_wsse) != SOAP_OK)
		goto error;
	if (soap_set_namespaces(*s, default_namespaces) != SOAP_OK)
		goto error;
	/* Create soap SSL context using 'hpcbp_certificate_path */
	if (soap_ssl_client_context(*s, SOAP_SSL_DEFAULT, NULL, NULL,
		NULL, hpcbp_certificate_path, NULL) != SOAP_OK) {
		sprintf(log_buffer, HPCBP_SSL_CNT_ERR);
		log_event(PBSEVENT_SYSTEM, PBS_EVENTCLASS_NODE, LOG_ERR,
			id, log_buffer);
		goto error;
	}
	/* Add user_name and password information to WSSE module */
	if (soap_wsse_add_UsernameTokenText(*s, NULL, user_name,
		password) != SOAP_OK) {
		sprintf(log_buffer, HPCBP_USER_ERR);
		log_event(PBSEVENT_SYSTEM, PBS_EVENTCLASS_NODE, LOG_ERR,
			id, log_buffer);
		goto error;
	}
	return 0;

error:
	hpcbp_soap_uninit(*s);
	return -1;
}

/*
 * hpcbp_write_datastaging_tojsdl function writes the stagein/stageout
 * directive information to the JSDL file.
 */

static void
hpcbp_write_datastaging_tojsdl(FILE *jsdl_file, char *from, char *to,
	char *remote_host, char *remote_file,
	char *stage_element, int delete_flag, char *user_name)
{

	/* Write DataStaing elements to the JSDL file */
	(void)fprintf(jsdl_file, "\t <%s>\n", DATA_STAGING);
	(void)fprintf(jsdl_file, "\t \t <%s> %s </%s>\n", FILE_NAME,
		from, FILE_NAME);
	(void)fprintf(jsdl_file, "\t \t <%s>overwrite</%s>\n",
		CREATION_FLAG, CREATION_FLAG);
	(void)fprintf(jsdl_file, "\t \t <%s>\n", stage_element);
	(void)fprintf(jsdl_file, "\t \t \t <%s>", URI);
	if (hpcbp_protocol_flag) { /* Port number specified */
		(void)fprintf(jsdl_file, "%s://%s:%s/%s",
			hpcbp_protocol, remote_host, hpcbp_port,
			remote_file);
	} else {
		(void)fprintf(jsdl_file, "%s://%s/%s", hpcbp_protocol,
			remote_host, remote_file);
	}
	(void)fprintf(jsdl_file, "</%s>\n", URI);
	(void)fprintf(jsdl_file, "\t \t </%s>\n", stage_element);
	if (delete_flag)
		(void)fprintf(jsdl_file, "\t \t <%s>true</%s>\n",
			DEL_ON_TERMINATE, DEL_ON_TERMINATE);
	(void)fprintf(jsdl_file, "\t \t <%s>\n \t \t \t <%s xmlns=\"%s\">\n",
		CREDENTIAL, USERNAME_TOKEN,
		CREDENTIAL_SCHEMA);
	(void)fprintf(jsdl_file, " \t \t \t \t <%s> %s </%s>\n", USERNAME,
		user_name, USERNAME);
	(void)fprintf(jsdl_file, "\t \t \t \t <%s></%s>\n", PASSWORD, PASSWORD);
	(void)fprintf(jsdl_file, "\t \t \t </%s>\n \t \t </%s>\n \t </%s>\n",
		USERNAME_TOKEN, CREDENTIAL, DATA_STAGING);
}



/*
 * hpcbp_add_datastaging_element fucntion is responsible for parsing
 * JOB_ATR_stagein, JOB_ATR_stageout attribute or JOB_ATR_outpath or
 * JOB_ATR_errpath and write <DataStaging> elements in JSDL document
 * Input arguments are
 *  parst = JOB_ATR_stagein/JOB_ATR_stageout directive info
 *      valid only if element_flag = HPCBP_JOB_STAGE_IN/HPCBP_JOB_STAGE_OUT
 *  jsdl_file = JSDL file pointer to where <DataStaging> elements
 * 	should be written
 *  element_flag = Type of element, legal values HPCBP_JOB_STAGE_IN,
 *		HPCBP_JOB_STAGE_OUT, HPCBP_JOB_STAGE_STDOUT
 *  user_name = name of user who has submitted the job
 *  filename = valid only if element_flag = HPCBP_JOB_STAGE_STDOUT
 * 		path of the stdout/stderr files
 *  delete_flag = 1, if 'JOB_ATR_keep' is set to 'o'/'e'/'oe'
 *  Returns '0' to indicate success, otherwise returns '-1'
 */

static int
hpcbp_add_datastaging_element(struct array_strings *parst,
	FILE *jsdl_file, int element_flag,
	char *user_name, char *filename,
	int delete_flag)
{
	char	*id = "hpcbp_add_datastaging_element";
	char	*plocal = NULL;
	char	*prmt = NULL;
	char	from[_POSIX_PATH_MAX + 1];
	char	to[_POSIX_PATH_MAX + 1];
	char	remote_host[PBS_MAXHOSTNAME + 1];
	char	remote_file[_POSIX_PATH_MAX + 1];
	char	*tmp = NULL;
	int	i = 0;
	int	ind = 0;
	char	*stage_element = TARGET;

	if (hpcbp_protocol == NULL) {
		if (hpcbp_parse_stage_protocol())
			return -1;
	}

	/* For JOB_ATR_stagein, need to write */
	/* <source> element in JSDL document */
	if (element_flag == HPCBP_JOB_STAGE_IN)
		stage_element = SOURCE;

	if ((element_flag == HPCBP_JOB_STAGE_IN) ||
		(element_flag == HPCBP_JOB_STAGE_OUT)) {
		for (i = 0; i < parst->as_usedptr; ++i) {
			plocal = parst->as_string[i];
			prmt = strchr(plocal, (int)'@');
			if (prmt) {
				*prmt = '\0';
				strncpy(from, plocal, _POSIX_PATH_MAX);
				from[_POSIX_PATH_MAX] = '\0';
				*prmt = '@';    /* restore the @ */
				strncpy(to, (prmt + 1), _POSIX_PATH_MAX);
				to[_POSIX_PATH_MAX] = '\0';
				DBPRT(("%s: From: %s\n", id, from))
				DBPRT(("%s: To: %s\n", id, to))
				/*
				 * In case of Stageout/Stagein directives
				 * user should specify remote host along with
				 * remote file information separated by ':'.
				 * Otherwise, qsub doesn't allow user
				 * to submit job. Once job comes to the
				 * PBS Server, it will not put any additional
				 * data before sending it to the MOM.
				 */
				ind = strchr(to, ':') - to;
				(void)strncpy(remote_host, to, ind);
				remote_host[ind] = '\0';
				tmp = (to + ind + 1);
				(void)strcpy(remote_file, tmp);
				hpcbp_write_datastaging_tojsdl(jsdl_file, from,
					to, remote_host, remote_file,
					stage_element, delete_flag, user_name);
			}
		}
	} else if (element_flag == HPCBP_JOB_STAGE_STDOUT) {
		/*
		 * If the paths are not specified by the client when the job
		 * is sent to the Server via the pbs_submit() API (a user's
		 * client), the Server will fill in using the defaults. It knows
		 * the qsub host from the client's IP address and the current
		 * working directory from the PBS_O_DIR environment variable
		 * send as part of the job submission. So, no need to check
		 * for return value of strchr(filename, ':'), as 'filename'
		 * always contains ':' character in it.
		 */
		ind = strchr(filename, ':') - filename;
		(void)strncpy(remote_host, filename, ind);
		remote_host[ind] = '\0';
		/* increment the pointer to point to char after ':' */
		tmp = filename + ind + 1;
		(void)strncpy(remote_file, tmp, _POSIX_PATH_MAX);
		remote_file[_POSIX_PATH_MAX] = '\0';
		(void)strncpy(from, lastname(remote_file), _POSIX_PATH_MAX);
		from[_POSIX_PATH_MAX] = '\0';
		hpcbp_write_datastaging_tojsdl(jsdl_file, from, to, remote_host,
			remote_file, stage_element, delete_flag, user_name);
	} else {
		sprintf(log_buffer, HPCBP_INVALID_ARG);
		log_err(LOG_ERR, id, log_buffer);
		return -1;
	}
	return (0);
}

/*
 * hpcbp_find_element() method checks for specific element
 * retuns '0' if it doesn't find an element. '1' if it finds an element.
 */

static int
hpcbp_find_element(struct soap_dom_element *dom, char *ns, char *elt)
{
	char *cp;

	if (!dom || !ns || !elt) {
		return 0;
	}
	if (strcmp(dom->nstr, ns)) {
		return 0;
	}
	cp = strchr(dom->name, ':');
	if (cp) {
		cp++;
	} else  {
		cp = dom->name;
	}
	if (strcmp(cp, elt)) {
		return 0;
	}
	return 1;
}

/*
 * hpcbp_match_attribute function matches attribute with 'elt'
 * returns '0' if they are not same and 1 if they are same.
 */

static int
hpcbp_match_attribute(struct soap_dom_attribute *attr, char *ns, char *elt)
{
	char *cp;

	if (!attr || !ns || !elt) {
		return 0;
	}
	if (strcmp(attr->nstr, ns)) {
		return 0;
	}
	cp = strchr(attr->name, ':');
	if (cp) {
		cp++;
	} else {
		cp = attr->name;
	}
	if (strcmp(cp, elt)) {
		return 0;
	}
	return 1;
}

/*
 * 'hpcbp_cleandom' function takes soap and dom_element structure
 * as input and cleans(frees) memory assigned to hold the dom
 * structure. It frees memory allocated to all child nodes under
 * this node.
 */

static void
hpcbp_cleandom(struct soap_dom_element *node)
{
	struct soap_dom_attribute *pattr;
	char *cp;

	if (node == NULL) {
		return;
	}
	cp = strchr(node->name, ':');
	if (cp) {
		cp++;
		node->name = cp;
	}
	if (node->nstr && strlen(node->nstr) == 0)
		node->nstr = NULL;
	pattr = node->atts;
	while (pattr) {
		cp = strchr(pattr->name, ':');
		if (cp) {
			cp++;
			pattr->name = cp;
		}
		if (pattr->nstr && strlen(pattr->nstr) == 0)
			pattr->nstr = NULL;
		pattr = pattr->next;
	}
	if (node->elts)
		hpcbp_cleandom(node->elts);
	if (node->next)
		hpcbp_cleandom(node->next);
}

/*
 * 'add_soapHeader' function adds 'Header' section to the SOAP
 * request message. It stores 'to', 'action' attributes with
 * appropriate values. It returns 0 for Success and -1 for failure.
 */
static int
add_soapHeader(struct soap *s, char *eprfile, enum hpcbp_req_t action)
{

	struct soap_dom_element *dom, *iter;
	struct soap_dom_element *refparams, *refparam;
	struct soap_dom_attribute *isrefparam;
	int epr, i, numrefparams;
	struct soap_dom_attribute *last, *attr;

	epr = open(eprfile, O_RDONLY);
	if (epr == -1)
		return -1;
	dom = (struct soap_dom_element*)soap_malloc(s,
		sizeof(struct soap_dom_element));
	if (dom == NULL) {
		close(epr);
		return -1;
	}
	memset(dom, 0, sizeof(struct soap_dom_element));
	soap_set_namespaces(s, epr_namespaces);
	dom->soap = s;
	dom->soap->recvfd = epr;
	if (soap_begin_recv(dom->soap) ||
		(soap_in_xsd__anyType(dom->soap,
		NULL, dom, NULL) == NULL) ||
		soap_end_recv(dom->soap)) {
		soap_set_namespaces(s, namespaces);
		close(epr);
		goto error;
	}
	close(epr);
	soap_set_namespaces(s, namespaces);
	iter = dom->elts;
	if (!iter || !hpcbp_find_element(iter, WSA_NS, "Address"))
		goto error;
	s->header->wsa__To.__item = iter->data;
	if (s->header->wsa__To.__item == NULL)
		goto error;

	if (action == HPCBP_REQUEST_QSUB)
		s->header->wsa__Action.__item = soap_strdup(s, CREATE_ACTION);
	else if (action == HPCBP_REQUEST_QSTAT)
		s->header->wsa__Action.__item = soap_strdup(s, STATUS_ACTION);
	else if (action == HPCBP_REQUEST_QDEL)
		s->header->wsa__Action.__item = soap_strdup(s,
			TERMINATE_ACTION);
	else if (action == HPCBP_REQUEST_PBSNODES)
		s->header->wsa__Action.__item = soap_strdup(s, FACTORY_ACTION);

	if (s->header->wsa__Action.__item == NULL)
		goto error;

	for (iter = iter->next; iter; iter = iter->next) {
		if (hpcbp_find_element(iter, WSA_NS, "ReferenceParameters")) {
			isrefparam = (struct soap_dom_attribute*)soap_malloc(s,
				sizeof(struct soap_dom_attribute));
			if (isrefparam == NULL)
				goto error;
			memset(isrefparam, 0,
				sizeof(struct soap_dom_attribute));
			isrefparam->soap = s;
			isrefparam->nstr = WSA_NS;
			isrefparam->name = soap_strdup(s,
				"wsa:IsReferenceParameter");
			isrefparam->data = soap_strdup(s, "true");
			if (!isrefparam->name || !isrefparam->data)
				goto error;

			numrefparams = 0;
			for (refparam = iter->elts; refparam != NULL;
				refparam = refparam->next) {
				if (refparam->atts) {
					attr = refparam->atts;
					last = refparam->atts;
					while (attr) {
						if (hpcbp_match_attribute(attr,
							WSA_NS,
							"IsReferenceParameter")) {

							attr->nstr = isrefparam->nstr;
							attr->name = isrefparam->name;
							attr->data = isrefparam->data;
							break;
						}
						last = attr;
						attr = attr->next;
					}
					if (!attr) {
						last->next = isrefparam;
					}
				} else {
					refparam->atts = isrefparam;
				}
				numrefparams++;
			}

			refparams = (struct soap_dom_element*)soap_malloc(s,
				sizeof(struct soap_dom_element)*numrefparams);
			if (refparams == NULL)
				goto error;
			memset(refparams, 0,
				sizeof(struct soap_dom_element)*numrefparams);
			refparam = iter->elts;
			for (i = 0; i < numrefparams; i++) {
				refparams[i].nstr = refparam->nstr;
				refparams[i].name = refparam->name;
				refparams[i].data = refparam->data;
				refparams[i].atts = refparam->atts;
				refparams[i].soap = refparam->soap;
				refparams[i].elts = refparam->elts;
				refparam = refparam->next;
			}

			s->header->__size = numrefparams;
			s->header->__any = refparams;
		}
	}
	return 0;
error:
	soap_end(dom->soap);
	soap_done(dom->soap);
	free(dom->soap);
	return -1;
}

/*
 * hpcbp_qstat_logmessage function logs job state transitions
 *  to the MOM log file
 */

void
hpcbp_qstat_logmessage(int old_hpcbp_status, int new_hpcbp_status,
	char *pbs_jobid, char *hpcbp_jobid)
{
	char *old_state = "Unknown";
	char *new_state;

	/*
	 * HPCBP Server can return 'Pending', 'Running', 'Finished',
	 * 'Terminated' or 'Failed' as a status of jobs. In case
	 * if it returns an error, then 'parse_qstat_response' method
	 * sets the status of job to "Unknown", so
	 * it is ok, not to check new_state limits.
	 */
	new_state = hpcbp_status2state[new_hpcbp_status];
	/* first time contacted HPCBP Server for job status */
	if (old_hpcbp_status == -1) {
		old_hpcbp_status = new_hpcbp_status;
		sprintf(log_buffer, "Job submitted to HPCBP Server as \
			jobid %s in state %s", hpcbp_jobid, new_state);
	} else {
		if (old_hpcbp_status == HPCBP_JOB_STATE_PENDING)
			old_state="Pending";
		else if (old_hpcbp_status == HPCBP_JOB_STATE_RUNNING)
			old_state = "Running";

		sprintf(log_buffer, "job transitioned from %s to %s",
			old_state, new_state);
	}

	log_event(PBSEVENT_JOB, PBS_EVENTCLASS_JOB, LOG_DEBUG,
		pbs_jobid, log_buffer);
}

/*
 * read_hpcbp_job_identifier() parses 'CreateActivity'
 * response message and constructs HPCBP JOb identifier
 * from 'ReferenceParameters' xml element.
 */

static void
read_hpcbp_job_identifier(struct soap *s,
	struct soap_dom_element *dom, char **hpcbp_jobid)
{
	struct 	soap_dom_element *iter;
	struct 	soap_dom_element *child;
	char	*prefix = "dom0";

	for (iter = dom; iter; iter = soap_dom_next_element(iter)) {
		/* Check for 'ReferenceParameters' element */
		if (strcmp(iter->name, "ReferenceParameters") == 0)
			break;
	}
	if (iter) {
		/* found 'ReferenceParameters' */
		child = iter->elts;
		/*
		 * format of hpcbp_jobid is as follows
		 * <prefix:child->name xmlns:prefix=
		 *	"child->nstr">child->data</prefix:child->name>"
		 * 	3 = prefix comes three times in jobid.
		 * 	12 = specical characters('<', '>', '/') for XML tags.
		 */
		*hpcbp_jobid = malloc((sizeof(prefix) * 3) +
			strlen(child->name) + sizeof("xmlns") +
			strlen(child->nstr) + strlen(child->data) +
			strlen(child->name) + 12);
		if (*hpcbp_jobid == NULL)
			return;
		sprintf(*hpcbp_jobid, "<%s:%s xmlns:%s=\"%s\">%s</%s:%s>",
			prefix, child->name, prefix, child->nstr,
			child->data, prefix, child->name);
	}
}


/*
 * hpcbp_parse_qdel_response() method parses 'TerminateActivities'
 * response message and returns 'HPCBP_JOB_TERMINATE_SUCCESS'
 * if HPCBP Server is able to terminate job
 * or 'HPCBP_JOB_TERMINATE_FAILED' if HPCBP Server is unable
 * to terminate job. Returns 'HPCBP_JOB_TERMINATE_UNDEFINED'
 * if it unable to find <Terminated> XML element in the response
 */

static int
hpcbp_parse_qdel_response(struct soap *soap,
	struct soap_dom_element *dom)
{
	DOID("hpcbp_parse_qdel_response")
	struct 	soap_dom_element *iter;

	for (iter = dom; iter; iter = soap_dom_next_element(iter)) {
		/* Check for 'Terminated' XML element */
		if (strcmp(iter->name, "Terminated") == 0) {
			/* If 'Terminated' XML element is true */
			/* job has terminated succesfully */
			DBPRT(("%s: terminate status: %s\n", id, iter->data))
			if (strcmp(iter->data, "true") == 0)
				return HPCBP_JOB_TERMINATE_SUCCESS;
			else
				return HPCBP_JOB_TERMINATE_FAILED;
		}
	}
	return HPCBP_JOB_TEMINATE_UNDEFINED;
}

/*
 * hpcbp_parse_qstat_response() method parses the 'GetActivityStauses'
 * response received from HPCBP Web service end point and returns
 * following states to the 'hpcbp_pbs_qstat' function.
 *
 * Legal states : Pending, Running, Finished, Cancelled, Failed
 * HPCBP_JOB_STATE_UNKNOWN if it doesn't find one of the above legal state
 */

static int
hpcbp_parse_qstat_response(struct soap *s, struct soap_dom_element *dom)
{
	DOID("hpcbp_parse_qstat_response")
	struct 	soap_dom_element *iter;
	struct 	soap_dom_attribute *attr;
	int 	state = HPCBP_JOB_STATE_UNKNOWN;

	for (iter = dom; iter; iter = soap_dom_next_element(iter)) {
		/* Check for 'ActivityStatus' XML element */
		if (strcmp(iter->name, "ActivityStatus") == 0) {
			/* Traverse through attribute lise */
			attr = iter->atts;
			for (; attr; attr = soap_dom_next_attribute(attr)) {
				if (strcmp(attr->name, "state"))
					continue;
				/* 'state' attribute found */
				DBPRT(("%s: job status: %s\n", id, attr->data))
				if (strcmp(attr->data, "Pending") == 0)
					state = HPCBP_JOB_STATE_PENDING;
				else if (strcmp(attr->data, "Running") == 0)
					state = HPCBP_JOB_STATE_RUNNING;
				else if (strcmp(attr->data, "Finished") == 0)
					state = HPCBP_JOB_STATE_FINISHED;
				else if (strcmp(attr->data, "Cancelled") == 0)
					state = HPCBP_JOB_STATE_TERMINATED;
				else if (strcmp(attr->data, "Failed") == 0)
					state = HPCBP_JOB_STATE_FAILED;
				return state;
			}
		}
	}
	return state; /* 'state' attribute not present in response */
}

/*
 * hpcbp_parse_pbsnodes_response() method parse
 * 'GetFactoryAttriutesDocument' response and populate vnlp structure
 * based on the information in the response. If any problem arises at
 * the time of parsing the response, it frees memory allocated to hold
 * HPCBP compute node information (vnodes).
 */

static void
hpcbp_parse_pbsnodes_response(struct soap *soap,
	struct soap_dom_element *dom, vnl_t **p_vnlp)
{
	char	*id = "hpcbp_parse_pbsnodes_response";
	struct 	soap_dom_element 	*iter;
	struct 	soap_dom_element 	*iter1;
	struct 	soap_dom_element 	*resource = NULL;
	u_Long				amt_mem_b;
	char				amt_mem_s[40];
	int 				os_flag = 0;
	int				number_of_vnodes = -1;
	int				i = -1;

	/* Read number of nodes present in HPCBP Server */
	for (iter = dom; iter; iter = soap_dom_next_element(iter)) {
		if (strcmp(iter->name,
			"TotalNumberOfContainedResources") == 0) {
			number_of_vnodes = atoi(iter->data);
			break;
		}
	}
	DBPRT(("%s: total number of vnodes: %d\n", id, number_of_vnodes))
	if (number_of_vnodes <= 0) {
		if (*p_vnlp != NULL) {
			vnl_free(*p_vnlp);
			*p_vnlp = NULL;
			return;
		}
	}
	if (hpcbp_vnodes)
		free(hpcbp_vnodes);
	hpcbp_vnodes = malloc(sizeof(char *) * number_of_vnodes);

	if (hpcbp_vnodes == NULL) {
		sprintf(log_buffer, HPCBP_MEM_ALLOC);
		log_err(LOG_ERR, id, log_buffer);
		return;
	}
	if (*p_vnlp != NULL) {
		vnl_free(*p_vnlp);
		*p_vnlp = NULL;
	}

	if (vnl_alloc(p_vnlp) == NULL) {
		sprintf(log_buffer, HPCBP_MEM_ALLOC);
		log_err(LOG_ERR, id, log_buffer);
		return;
	}

	for (iter = dom; iter; iter = soap_dom_next_element(iter)) {
		if (strcmp(iter->name, "ContainedResource") == 0) {
			resource = iter->elts;
			for (iter1 = resource; iter1;
				iter1 = soap_dom_next_element(iter1)) {
				if (strcmp(iter1->name, "ResourceName") == 0) {
					if (i >= number_of_vnodes)
						goto hpcp_vn_create_exit;
					i++;	/* new node */
					DBPRT(("%s: vnode hostname: %s\n", id,
						iter1->data))
					hpcbp_vnodes[i] = strdup(iter1->data);
					if (hpcbp_vnodes[i] == NULL) {
						sprintf(log_buffer,
							HPCBP_MEM_ALLOC);
						log_err(LOG_ERR, id,
							log_buffer);
						goto hpcp_vn_create_exit;
					}
					if (vn_addvnr(*p_vnlp, hpcbp_vnodes[i],
						"resources_available.host",
						hpcbp_vnodes[i],
						0, 0, NULL) == -1)
						goto hpcp_vn_create_exit;
				}
				if (strcmp(iter1->name,
					"OperatingSystemName") == 0) {
					if (strcmp(iter1->data,
						"other") == 0) {
						os_flag = 1;
					} else {
						char *arch =
							"resources_available.arch";
						if (vn_addvnr(*p_vnlp,
							hpcbp_vnodes[i],
							arch,
							iter1->data,
							0, 0,
							NULL) == -1)
							goto hpcp_vn_create_exit;
					}
				}
				if (strcmp(iter1->name,
					"OperatingSystemVersion") == 0) {
					if (os_flag) {
						if (vn_addvnr(*p_vnlp,
							hpcbp_vnodes[i],
							"resources_available.arch",
							iter1->data,
							0, 0,
							NULL) == -1)
							goto hpcp_vn_create_exit;
					}
				}
				if (strcmp(iter1->name, "CPUCount") == 0) {
					if (vn_addvnr(*p_vnlp,
						hpcbp_vnodes[i],
						"resources_available.ncpus",
						iter1->data,
						0, 0, NULL) == -1)
						goto hpcp_vn_create_exit;
				}
				if (strcmp(iter1->name,
					"PhysicalMemory") == 0) {
					DBPRT(("%s: mem: %s\n",
						id, iter1->data))
					amt_mem_b = atoll(iter1->data);
					/*
					 * Got memory in bytes,
					 * so convert it into kb
					 */
					sprintf(amt_mem_s, "%llukb",
						amt_mem_b/1024);
					if (vn_addvnr(*p_vnlp, hpcbp_vnodes[i],
						"resources_available.mem",
						amt_mem_s, 0, 0, NULL) == -1)
						goto hpcp_vn_create_exit;
				}
			}
			break;
		}
	}
	(*p_vnlp)->vnl_modtime = time((time_t *)0);
	return;

hpcp_vn_create_exit:
	if (*p_vnlp != NULL) {
		vnl_free(*p_vnlp);
		*p_vnlp = NULL;
	}
	return;
}

/*
 * hpcbp_fetch_server_certificate routine uses OpenSSL API
 * to connect to the HPCBP Server(https). It fetches server
 * certificate and stores it in 'hpcbp_certificate_path' file.
 * Returns 0 on Success and -1 for Failure.
 */

int
hpcbp_fetch_server_certificate()
{
	static	char	id[] = "hpcbp_fetch_server_certificate";
	BIO 		*bio = NULL;
	SSL 		*ssl = NULL;
	SSL_CTX 	*ctx = NULL;
	X509		*x509 = NULL;
	BIO 		*cert_file;
	FILE 		*fp = NULL;
	int 		i;
	int		j = 0;
	int		k = 0;
	int		colon_flag = 0;
	static void 	*handle = NULL;
	static char	openssl[] = "libssl.so";
	struct hostent	*hp = NULL;
	char	hostname_with_port[PBS_MAXHOSTNAME + PBS_MAXPORTNUM + 2];
	char		hostname_without_port[PBS_MAXHOSTNAME + 1];
	char		port_number[10];
	int		rcode = -1;
	int		colon_index = 0;

	/* Check for libssl library package */
	if ((handle == NULL) &&
		(handle = dlopen(openssl, RTLD_LAZY)) == NULL) {
		sprintf(log_buffer, HPCBP_OPENSSL_ERR);
		log_event(PBSEVENT_SYSTEM, PBS_EVENTCLASS_NODE,
			LOG_ERR, id, log_buffer);
		return rcode;
	}
	if (handle != NULL) {
		(void) dlclose(handle);
		handle = NULL;
	}

	/*
	 * hpcbp_webservice_address starts with 'https://'. If not HPCBP MOM
	 * would has thrown an error at the time of reading HPCBP attributes
	 * from the PBS Server as a part of IS_HPCBP_ATTRIBUTES.
	 */
	for (i = strlen("https://"); hpcbp_webservice_address[i]; i++, j++) {
		if (hpcbp_webservice_address[i] == '/')
			break;
		/* Port number specified */
		if (hpcbp_webservice_address[i] == ':') {
			colon_flag = 1;
			colon_index = j;
		}
		hostname_with_port[j] = hpcbp_webservice_address[i];
	}
	hostname_with_port[j] = '\0';
	DBPRT(("%s: host_name_with_port: %s\n", id, hostname_with_port))

	if (colon_flag) {
		/*
		 * Port number specified, then copy hostname
		 * and port information into diffrent variables
		 */
		strncpy(hostname_without_port, hostname_with_port,
			colon_index);
		hostname_without_port[colon_index] = '\0';
		/* Copy port information */
		for (k = colon_index + 1, j = 0;
			hostname_with_port[k] != '\0'; k++, j++)
			port_number[j] = hostname_with_port[k];
		port_number[j] = '\0';
	} else {
		/* Copy contents to hostname_without_port */
		for (i = 0; hostname_with_port[i] != '\0'; i++)
			hostname_without_port[i] = hostname_with_port[i];
		hostname_without_port[i] = '\0';
	}
	DBPRT(("%s : hostname_without_port: %s\n", id, hostname_without_port))
	/* Check whether MOM is able to resolve hostname */
	hp = gethostbyname(hostname_without_port);
	if (hp == NULL) {	/* unable to resolve, problem with parsing */
		sprintf(log_buffer, HPCBP_CNT_RES);
		log_event(PBSEVENT_SYSTEM, PBS_EVENTCLASS_NODE,
			LOG_ERR, id, log_buffer);
		return rcode;
	}

	/* Setup  & Intialize OpenSSL the library */
	ERR_load_BIO_strings();
	SSL_load_error_strings();
	OpenSSL_add_all_algorithms();
	SSL_library_init();
	/* Set up the SSL Context */
	ctx = SSL_CTX_new(SSLv23_client_method());
	if (ctx == NULL) {
		sprintf(log_buffer, HPCBP_CNT_SSL);
		log_err(-1, id, log_buffer);
		return rcode;
	}

	/* Setup the connection */
	bio = BIO_new_ssl_connect(ctx);
	if (bio == NULL) {
		sprintf(log_buffer, HPCBP_CNT_CONNECT);
		log_err(-1, id, log_buffer);
		goto err;
	}

	BIO_get_ssl(bio, &ssl);
	if (!ssl) {
		sprintf(log_buffer, HPCBP_CNT_SSL);
		log_err(-1, id, log_buffer);
		goto err;
	}

	/* Setup the SSL_MODE_AUTO_RETRY flag */
	SSL_set_mode(ssl, SSL_MODE_AUTO_RETRY);

	/* Create and setup the Connection */
	BIO_set_conn_hostname(bio, hostname_without_port);
	/* Set port number */
	if (colon_flag)
		BIO_set_conn_port(bio, port_number);
	else
		BIO_set_conn_port(bio, HPCBP_SERVER_PORT);

	if (BIO_do_connect(bio) < 0) {
		sprintf(log_buffer, HPCBP_CNT_CONNECT);
		log_err(-1, id, log_buffer);
		goto err;
	}

	/* Retrieving server certificate */
	x509 = SSL_get_peer_certificate(ssl);
	if (x509 == NULL) {
		sprintf(log_buffer, HPCBP_FETCH_CERT);
		log_err(-1, id, log_buffer);
		goto err;
	}

	DBPRT(("%s: HPCBP Certificate path: %s\n", id, hpcbp_certificate_path))
	fp = fopen(hpcbp_certificate_path, "w");
	if (fp == NULL) {
		sprintf(log_buffer, HPCBP_CERT_CREATE);
		log_err(-1, id, log_buffer);
		goto err;
	}

	cert_file = BIO_new_fp(fp, BIO_CLOSE);
	if (cert_file == NULL) {
		sprintf(log_buffer, HPCBP_CERT_CREATE);
		log_err(-1, id, log_buffer);
		goto err;
	}

	/* Write certificate to file */
	if (!PEM_write_bio_X509(cert_file, x509)) {
		sprintf(log_buffer, HPCBP_CERT_WRITE);
		log_err(-1, id, log_buffer);
		goto err;
	}

	rcode = 0;
err:
	if (fp)
		fclose(fp);
	if (bio)
		BIO_free_all(bio);
	if (ctx)
		SSL_CTX_free(ctx);
	return rcode;
}

/*
 * hpcbp_create_endpoint_reference() method creates an HPCBP Server
 * Endpoint reference file 'endpoint.xml' inside 'PBS_HOME/mom_priv/'
 * directory. If endpoint.xml file is already present, then it overwrites
 * the existing file with new 'hpcbp_webservice_address'.
 * Returns 0 for Success and -1 for Failure.
 */

int
hpcbp_create_endpoint_reference()
{
	static  char id[] = "hpcbp_create_endpoint_reference";
	FILE 	*hpcbp_epr;

	if (hpcbp_protocol) {
		free(hpcbp_protocol);
		hpcbp_protocol = NULL;
	}
	hpcbp_epr = fopen(hpcbp_endpoint_reference, "w");
	if (hpcbp_epr == NULL) {
		sprintf(log_buffer, HPCBP_END_ERR);
		log_event(PBSEVENT_SYSTEM, PBS_EVENTCLASS_NODE,
			LOG_ERR, id, log_buffer);
		return -1;
	}
	(void)fprintf(hpcbp_epr,
		"<?xml version=\"1.0\" encoding=\"UTF-8\" ?> \n");
	(void)fprintf(hpcbp_epr, "<%s xmlns:wsa=\"%s\"> \n",
		WSA_ENDPOINT, WSA_SCHEMA);
	(void)fprintf(hpcbp_epr, "\t<%s>%s</%s> \n", WSA_ADDRESS,
		hpcbp_webservice_address, WSA_ADDRESS);
	(void)fprintf(hpcbp_epr, "</%s>", WSA_ENDPOINT);
	fclose(hpcbp_epr);
	return 0;
}

/*
 * hpcbp_remove_temp() function takes pbs_jobid as input and removes
 * .JSDL & .xml files created inside tmpdir for the job
 */

void
hpcbp_remove_temp(char *pbs_jobid)
{
	DOID("hpcbp_remove_temp")
	char activity_identifier[_POSIX_PATH_MAX];
	char jsdl_script_file_path[_POSIX_PATH_MAX];

	(void)sprintf(activity_identifier, "%s/%s.xml",
		tmpdirname(pbs_jobid), pbs_jobid);
	(void)sprintf(jsdl_script_file_path, "%s/%s.jsdl",
		tmpdirname(pbs_jobid), pbs_jobid);
	DBPRT(("%s: PBS Job ID: %s : Activity Identifier: %s\n", id,
		jsdl_script_file_path, activity_identifier))
	unlink(activity_identifier);
	unlink(jsdl_script_file_path);
}

/*
 * hpcbp_convert_pbstojsdl() functions parses the PBS job request
 * and converts it into JSDL request. It creates JSDL file in
 * 'PBS_HOME'/mom_prov/jobs/<pbs-jobid>.jsdl' directory.
 * Returns 0 on Successful creation of JSDL document and -1 for failure.
 */

static int
hpcbp_convert_pbstojsdl(char *jsdl_file_path, job *pjob)
{
	char			*id = "hpcbp_convert_pbstojsdl";
	FILE 			*jsdl_file = NULL;
	char			*tmp = NULL;
	char			*tmp1 = NULL;
	int			j = 0, size = 0;
	char 			*arch_osname = "other";
	char			*arch_osversion = NULL;
	resource 		*pres;
	char 			*pname;
	unsigned long		value;
	int             	retval;
	struct array_strings 	*parst;
	struct  array_strings   *vstrs = NULL;
	hnodent			*hn = NULL;
	host_vlist_t		*hv = NULL;
	int			total_number_of_ncpus = 0;
	int			ret = -1;
	int			delete_flag = 1;
	static char		pbs_env[] = "PBS_";
	attribute       	*pattr;
	char			*sout, *serr; /* store std out/err file path */
	int			is_joined_ret = 0;	/* no join */

	pattr = &pjob->ji_wattr[(int)JOB_ATR_executable];
	if (strcmp(lastname(pattr->at_val.at_str), "pbsdsh") == 0) {
		/* user has specified 'pbsdsh' as an executable */
		return -1;
	}
	/* Creating JSDL document for job submission */
	DBPRT(("%s: JSDL file path: %s\n", id, jsdl_file_path))
	jsdl_file = fopen(jsdl_file_path, "w");
	if (jsdl_file == NULL) {
		sprintf(log_buffer, HPCBP_JSDL_ERR);
		log_joberr(-1, id, log_buffer, pjob->ji_qs.ji_jobid);
		goto error;
	}
	(void)fprintf(jsdl_file,
		"<?xml version=\"1.0\" encoding=\"utf-8\"?> \n");
	(void)fprintf(jsdl_file, "<%s \t xmlns:jsdl=\"%s\"",
		JOB_DEFINITION, JSDL_SCHEMA);
	(void)fprintf(jsdl_file, "\t xmlns:jsdl-hpcpa=\"%s\"",
		JSDL_HPCPA_SCHEMA);
	(void)fprintf(jsdl_file, "\t xmlns:xsi=\"%s\">\n", XSI_SCHEMA);
	(void)fprintf(jsdl_file, "\t <%s>\n", JOB_DESCRIPTION);
	(void)fprintf(jsdl_file, "\t \t <%s>\n", JOB_IDENT);
	(void)fprintf(jsdl_file, "\t \t \t<%s>%s</%s>\n", JOB_NAME,
		pjob->ji_wattr[(int)JOB_ATR_jobname].at_val.at_str,
		JOB_NAME);
	(void)fprintf(jsdl_file,
		"\t \t \t<%s> PBS-TO-HPCP </%s> \n \t \t</%s>\n",
		JOB_PROJECT , JOB_PROJECT , JOB_IDENT);
	(void)fprintf(jsdl_file, "\t <%s> \n \t \t <%s name=\"PBStoHPCP\">\n",
		APPLICATION, HPCPA_APPLICATION);
	(void)fprintf(jsdl_file, "\t \t \t <%s>%s</%s>\n", HPCPA_EXECUTABLE,
		pattr->at_val.at_str, HPCPA_EXECUTABLE);
	/* Add all arguments to JSDL document */
	pattr = &pjob->ji_wattr[(int)JOB_ATR_Arglist];
	fprintf(jsdl_file, "\t \t \t %s\n", pattr->at_val.at_str);

	is_joined_ret = is_joined(pjob);
	if (is_joined_ret == 1) { /* joined, as stdout */
		sout = pjob->ji_wattr[(int)JOB_ATR_outpath].at_val.at_str;
		serr = pjob->ji_wattr[(int)JOB_ATR_outpath].at_val.at_str;
	} else if (is_joined_ret == -1) { /* joined as stderr */
		sout = pjob->ji_wattr[(int)JOB_ATR_errpath].at_val.at_str;
		serr = pjob->ji_wattr[(int)JOB_ATR_errpath].at_val.at_str;
	} else {        /* no join, separate files */
		sout = pjob->ji_wattr[(int)JOB_ATR_outpath].at_val.at_str;
		serr = pjob->ji_wattr[(int)JOB_ATR_errpath].at_val.at_str;
	}
	/* Write STDOUT and STDERR file paths to JSDL document */
	(void)fprintf(jsdl_file, "\t \t \t <%s>%s</%s>\n", HPCPA_OUTPUT,
		lastname(sout), HPCPA_OUTPUT);
	(void)fprintf(jsdl_file, "\t \t \t <%s>%s</%s>\n", HPCPA_ERROR,
		lastname(serr), HPCPA_ERROR);

	/* Add environment variables to JSDL document, if any */
	if (pjob->ji_wattr[(int)JOB_ATR_variables].at_flags & ATR_VFLAG_SET) {
		int i = 0;
		vstrs = pjob->ji_wattr[(int)JOB_ATR_variables].at_val.at_arst;
		for (j = 0; j < vstrs->as_usedptr; ++j) {
			/* If it is a PBS default env variable, then ignore */
			if ((strncmp(vstrs->as_string[j], pbs_env,
				(sizeof(pbs_env) - 1))) == 0)
				continue;
			tmp = vstrs->as_string[j];
			(void)fprintf(jsdl_file, "\t \t \t <%s ",
				HPCPA_ENVIRONMENT);
			for (i = 0; tmp[i] != '\0'; i++) {
				if (tmp[i] == '=') {
					/* '=' character found */
					tmp1 = tmp + i + 1;
					tmp[i] = '\0';
					DBPRT(("Env variable = %s\n", tmp))
					DBPRT(("Env value = %s\n", tmp1))
					(void)fprintf(jsdl_file,
						"name=\"%s\">%s", tmp, tmp1);
					tmp[i] = '=';	/* Restore '=' */
					break;
				}
			}
			(void)fprintf(jsdl_file, "</%s>\n", HPCPA_ENVIRONMENT);
		}
	}

	/* Add OMP_NUM_THREADS env variable to JSDL document, if present */
	if (hpcbp_ompthreads) {
		(void)fprintf(jsdl_file,
			"\t \t \t <%s name=\"OMP_NUM_THREADS\">%d</%s>\n",
			HPCPA_ENVIRONMENT,  hpcbp_ompthreads,
			HPCPA_ENVIRONMENT);
	}
	(void)fprintf(jsdl_file, "\t \t </%s> \n \t</%s>\n",
		HPCPA_APPLICATION, APPLICATION);
	fprintf(jsdl_file, "\t <%s>\n", RESOURCES);

	/* Add Candidate Host list to the JSDL document */
	fprintf(jsdl_file, "\t \t <%s>\n", CANDIDATE_HOSTS);
	hn = &pjob->ji_hosts[pjob->ji_nodeid];
	for (j = 0; j < hn->hn_vlnum; j++) {
		hv = &hn->hn_vlist[j];
		(void)fprintf(jsdl_file, "\t \t \t <%s>%s</%s>\n",
			JOB_HOSTNAME,  hv->hv_vname, JOB_HOSTNAME);
		total_number_of_ncpus += hv->hv_ncpus;
	}
	(void)fprintf(jsdl_file, "\t \t </%s>\n", CANDIDATE_HOSTS);

	/* Add aggregate number of ncpus to the JSDL document */
	DBPRT(("%s: aggregate ncpus: %d\n", id, total_number_of_ncpus))
	if (total_number_of_ncpus) {
		(void)fprintf(jsdl_file, "\t \t <%s>\n", TOTAL_CPU_COUNT);
		(void)fprintf(jsdl_file, "\t \t \t <%s>%d</%s>\n",
			UPPER_BOUND_RANGE, total_number_of_ncpus,
			UPPER_BOUND_RANGE);
		(void)fprintf(jsdl_file, "\t \t \t <%s>%d</%s>\n",
			LOWER_BOUND_RANGE, total_number_of_ncpus,
			LOWER_BOUND_RANGE);
		(void)fprintf(jsdl_file, "\t \t </%s>\n", TOTAL_CPU_COUNT);
	}

	/* Traversing throught the resource specifications */
	pres = (resource *)
		GET_NEXT(pjob->ji_wattr[(int)JOB_ATR_resource].at_val.at_list);
	while (pres != NULL) {
		assert(pres->rs_defin != NULL);
		pname = pres->rs_defin->rs_name;
		assert(pname != NULL);
		assert(*pname != '\0');
		if (strcmp(pname, "cput") == 0) {	/* cput set */
			retval = local_gettime(pres, &value);
			if (retval != PBSE_NONE)
				goto error;
			DBPRT(("%s: cput: %ld\n", id, value))
			(void)fprintf(jsdl_file, "\t \t <%s>\n",
				TOTAL_CPU_TIME);
			(void)fprintf(jsdl_file, "\t \t \t <%s>%ld</%s>\n",
				UPPER_BOUND_RANGE, value,
				UPPER_BOUND_RANGE);
			(void)fprintf(jsdl_file, "\t \t </%s>\n",
				TOTAL_CPU_TIME);
		} else if (strcmp(pname, "pcput") == 0) {	/* pcput set */
			retval = local_gettime(pres, &value);
			if (retval != PBSE_NONE)
				goto error;
			DBPRT(("%s: pcput: %ld\n", id, value))
			(void)fprintf(jsdl_file, "\t \t <%s>\n",
				IND_CPU_TIME);
			(void)fprintf(jsdl_file, "\t \t \t <%s>%ld</%s>\n",
				UPPER_BOUND_RANGE, value,
				UPPER_BOUND_RANGE);
			(void)fprintf(jsdl_file, "\t \t </%s>\n",
				IND_CPU_TIME);
		} else if (strcmp(pname, "pvmem") == 0) {	/* pvmem set */
			retval = local_getsize(pres, &value);
			if (retval != PBSE_NONE)
				goto error;
			DBPRT(("%s: pvmem: %ld\n", id, value))
			(void)fprintf(jsdl_file, "\t \t <%s>\n",
				IND_VIRTUAL_MEM);
			(void)fprintf(jsdl_file, "\t \t \t <%s>%ld</%s>\n",
				UPPER_BOUND_RANGE, value,
				UPPER_BOUND_RANGE);
			(void)fprintf(jsdl_file, "\t \t </%s>\n",
				IND_VIRTUAL_MEM);
		} else if (strcmp(pname, "pmem") == 0) {        /* pmem set */
			retval = local_getsize(pres, &value);
			if (retval != PBSE_NONE)
				goto error;
			DBPRT(("%s: pmem: %ld\n", id, value))
			(void)fprintf(jsdl_file, "\t \t <%s>\n",
				IND_PHY_MEM);
			(void)fprintf(jsdl_file, "\t \t \t <%s>%ld</%s>\n",
				UPPER_BOUND_RANGE, value,
				UPPER_BOUND_RANGE);
			(void)fprintf(jsdl_file, "\t \t </%s>\n",
				IND_PHY_MEM);
		} else if (strcmp(pname, "mem") == 0) {        /* mem set */
			retval = local_getsize(pres, &value);
			if (retval != PBSE_NONE)
				goto error;
			DBPRT(("%s: pmem: %ld\n", id, value))
			(void)fprintf(jsdl_file, "\t \t <%s>\n",
				TOTAL_MEM);
			(void)fprintf(jsdl_file, "\t \t \t <%s>%ld</%s>\n",
				UPPER_BOUND_RANGE, value,
				UPPER_BOUND_RANGE);
			(void)fprintf(jsdl_file, "\t \t </%s>\n",
				TOTAL_MEM);
		} else if (strcmp(pname, "file") == 0) {        /* file set  */
			retval = local_getsize(pres, &value);
			if (retval != PBSE_NONE)
				goto error;
			DBPRT(("%s: file: %ld\n", id, value))
			(void)fprintf(jsdl_file, "\t \t <%s>\n",
				IND_DISK_SPACE);
			(void)fprintf(jsdl_file, "\t \t \t <%s>%ld</%s>\n",
				UPPER_BOUND_RANGE, value,
				UPPER_BOUND_RANGE);
			(void)fprintf(jsdl_file, "\t \t </%s>\n",
				IND_DISK_SPACE);
		} else if (strcmp(pname, "nice") == 0) {
			/* 'nice' attribute is not supported */
			sprintf(log_buffer, HPCBP_NICE_WARN);
			log_event(PBSEVENT_JOB, PBS_EVENTCLASS_JOB, LOG_WARNING,
				pjob->ji_qs.ji_jobid, log_buffer);
		} else if (strcmp(pname, "arch") == 0) {	/* arch set */
			arch_osversion = pres->rs_value.at_val.at_str;
		}
		pres = (resource *)GET_NEXT(pres->rs_link);
	}

	/* Store 'arch'(if specified) in JSDL document */
	if (arch_osversion != NULL) {
		(void)fprintf(jsdl_file, "\t \t <%s>\n", OPERATING_SYSTEM);
		(void)fprintf(jsdl_file, "\t \t \t <%s>\n", OS_TYPE);
		size = sizeof(arch_values) / sizeof(arch_values[0]);
		for (j = 0; j < size; j++) {
			if (strcmp(arch_values[j].arch_value,
				arch_osversion) == 0) {
				arch_osname = arch_values[j].arch_osname;
				if (arch_values[j].arch_osversion != NULL)
					arch_osversion =
						arch_values[j].arch_osversion;
				break;
			}
		}
		DBPRT(("%s : osname = %s\n", id, arch_osname))
		DBPRT(("%s : osversion = %s\n", id, arch_osname))
		(void)fprintf(jsdl_file, "\t \t \t \t<%s>%s</%s>\n",
			OS_NAME, arch_osname, OS_NAME);
		(void)fprintf(jsdl_file, "\t \t \t <%s>%s</%s>\n",
			OS_VERSION, arch_osversion, OS_VERSION);
		(void)fprintf(jsdl_file, "\t \t \t </%s>\n", OS_TYPE);
		(void)fprintf(jsdl_file, "\t \t </%s>\n", OPERATING_SYSTEM);
	}
	(void)fprintf(jsdl_file, "\t </%s>\n", RESOURCES);

	/* Add Staging inforamtion for STDOUT and STDERR files */
	if ((is_joined_ret != -1) &&
		(strchr(pjob->ji_wattr[(int)JOB_ATR_keep].at_val.at_str,
		'o') == NULL)) {
		/* join as stdout (or) no join (or) don't keep .o file */
		ret = hpcbp_add_datastaging_element(NULL, jsdl_file,
			HPCBP_JOB_STAGE_STDOUT,
			pjob->ji_wattr[(int)JOB_ATR_euser].at_val.at_str,
			pjob->ji_wattr[(int)JOB_ATR_outpath].at_val.at_str,
			delete_flag);
		if (ret)
			goto error;
	}
	if ((is_joined_ret != 1) &&
		(strchr(pjob->ji_wattr[(int)JOB_ATR_keep].at_val.at_str,
		'e') == NULL)) {
		/* join as stderr (or) no join (or) don't keep .e file */
		ret = hpcbp_add_datastaging_element(NULL, jsdl_file,
			HPCBP_JOB_STAGE_STDOUT,
			pjob->ji_wattr[(int)JOB_ATR_euser].at_val.at_str,
			pjob->ji_wattr[(int)JOB_ATR_errpath].at_val.at_str,
			delete_flag);
		if (ret)
			goto error;
	}

	/* Add Staging information for -W stagein directive */
	if (pjob->ji_wattr[(int)JOB_ATR_stagein].at_flags & ATR_VFLAG_SET) {
		parst=pjob->ji_wattr[(int)JOB_ATR_stagein].at_val.at_arst;
		ret = hpcbp_add_datastaging_element(parst, jsdl_file,
			HPCBP_JOB_STAGE_IN,
			pjob->ji_wattr[(int)JOB_ATR_euser].at_val.at_str,
			NULL, delete_flag);
		if (ret)
			goto error;
	}

	/* Add Staging information for -W stageout directive */
	if (pjob->ji_wattr[(int)JOB_ATR_stageout].at_flags & ATR_VFLAG_SET) {
		parst=pjob->ji_wattr[(int)JOB_ATR_stageout].at_val.at_arst;
		ret =  hpcbp_add_datastaging_element(parst, jsdl_file,
			HPCBP_JOB_STAGE_OUT,
			pjob->ji_wattr[(int)JOB_ATR_euser].at_val.at_str,
			NULL, delete_flag);
		if (ret)
			goto error;
	}
	(void)fprintf(jsdl_file, "\t </%s>\n</%s>\n",
		JOB_DESCRIPTION, JOB_DEFINITION);
	if (ferror(jsdl_file)) {
		sprintf(log_buffer, HPCBP_JSDL_SCRIPT);
		log_joberr(-1, id, log_buffer, pjob->ji_qs.ji_jobid);
	}

	/* Ignore JOB_ATR_shell  attribute */
	if ((pjob->ji_wattr[(int)JOB_ATR_shell].at_flags & ATR_VFLAG_SET)) {
		sprintf(log_buffer, HPCBP_SHELL_WARN);
		log_event(PBSEVENT_JOB, PBS_EVENTCLASS_JOB, LOG_WARNING,
			pjob->ji_qs.ji_jobid, log_buffer);
	}
	/* Ignore  JOB_ATR_grouplst attribute */
	if ((pjob->ji_wattr[(int)JOB_ATR_grouplst].at_flags & ATR_VFLAG_SET)) {
		sprintf(log_buffer, HPCBP_GRP_WARN);
		log_event(PBSEVENT_JOB, PBS_EVENTCLASS_JOB, LOG_WARNING,
			pjob->ji_qs.ji_jobid, log_buffer);
	}
	/* Ignore JOB_ATR_umask  attribute */
	if ((pjob->ji_wattr[(int)JOB_ATR_umask].at_flags & ATR_VFLAG_SET)) {
		sprintf(log_buffer, HPCBP_MASK_WARN);
		log_event(PBSEVENT_JOB, PBS_EVENTCLASS_JOB, LOG_WARNING,
			pjob->ji_qs.ji_jobid, log_buffer);
	}
	fclose(jsdl_file);
	return 0;

error:
	if (jsdl_file)
		fclose(jsdl_file);
	return (-1);
}

/*
 * 'hpcbp_precheck' function does pre-processing before
 * sending SOAP request to the HPCBP Server. It performs following
 * tasks and returns -1 if any of them fail.
 *  Task 1 -- Check for HPCBP Endpoint refernece file
 *	If it is not present, it creates it
 *		(using 'hpcbp_create_endpiont_reference').
 * Task 2 -- Based on request type, it decrypts credential info.
 *	If request type is HPCBP_REQUEST_QSUB then it assigns
 *	password to 'hpcbp_user_password(input argument).
 * Task 3 -- Creates gSOAP run-time environment
 * Task 4 -- Adds SOAP Header to the request message.
 * 	If it is unable to add it, then logs an error message.
 */

int
hpcbp_precheck(enum hpcbp_req_t request_flag, job *pjob, struct soap **s,
	char **hpcbp_user_password, char *pbs_jobid,
	char *hpcbp_reguser_credbuf, size_t hpcbp_reguser_credlen)
{

	char 	*id = "hpcbp_precheck";
	char	*password = NULL;	/* store decrypted password */
	int	ret = 0;
	size_t	tmp_credlen = 0;

	/* Check for 'PBS_HOME/mom_priv/endpoint.xml' file */
	/* This pre-condition should be checked for all requests */
	if (access(hpcbp_endpoint_reference, F_OK | R_OK)) {
		ret = hpcbp_create_endpoint_reference();
		if (ret)
			return -1;
	}
	/* Decrypt password based on request type */
	if ((request_flag == HPCBP_REQUEST_QSTAT) ||
		(request_flag == HPCBP_REQUEST_PBSNODES)) {
		if (pbs_decrypt_pwd(hpcbp_user_credbuf, PBS_CREDTYPE_AES, hpcbp_user_credlen,
			&password)) {
			sprintf(log_buffer, HPCBP_DECRYPT_ERR);
			log_joberr(-1, id, log_buffer, pbs_jobid);
			goto error;
		} else {
			password[hpcbp_user_credlen] ='\0';
			tmp_credlen = hpcbp_user_credlen;
		}
	} else {
		/* Decrypt credential */
		if (pbs_decrypt_pwd(hpcbp_reguser_credbuf, PBS_CREDTYPE_AES, hpcbp_reguser_credlen,
			&password)) {
			sprintf(log_buffer, HPCBP_DECRYPT_ERR);
			log_joberr(-1, id, log_buffer, pbs_jobid);
			goto error;
		} else {
			password[hpcbp_reguser_credlen] = '\0';
			tmp_credlen = hpcbp_reguser_credlen;
		}
		/* free memory allocated for hpcbp_reguser_credbuf */
		/* It is allocated in finish_exec in read_cred call */
		if (hpcbp_reguser_credbuf) {
			/* overwrite password with '0' character */
			memset(hpcbp_reguser_credbuf, 0,
				hpcbp_reguser_credlen);
			free(hpcbp_reguser_credbuf);
			hpcbp_reguser_credbuf = NULL;
		}

		if (request_flag == HPCBP_REQUEST_QSUB) {
			/*
			 * Request Type is HPCBP_REQUEST_QSUB
			 * Store user's decrypted password in
			 * input argument.
			 */
			*hpcbp_user_password = password;
		}
	}
	/* Initialize gSOAP environment based on request type */
	if ((request_flag == HPCBP_REQUEST_QSTAT) ||
		(request_flag == HPCBP_REQUEST_PBSNODES)) {
		ret = hpcbp_soap_init(hpcbp_user_name, password, s);
	} else {
		char *p = pjob->ji_wattr[(int)JOB_ATR_euser].at_val.at_str;
		ret = hpcbp_soap_init(p, password, s);
	}
	if (ret) {
		/* unable to create gSOAP runtime environment */
		sprintf(log_buffer, HPCBP_GSOAP_INIT);
		log_joberr(-1, id, log_buffer, pbs_jobid);
		goto error;
	}
	/* Add Header to the SOAP request message */
	ret = add_soapHeader(*s, hpcbp_endpoint_reference, request_flag);
	if (ret) {
		if (request_flag == HPCBP_REQUEST_PBSNODES) {
			sprintf(log_buffer, HPCBP_HEAD_NODES);
			log_err(-1, id, log_buffer);
		} else {
			if (request_flag == HPCBP_REQUEST_QSUB)
				sprintf(log_buffer, HPCBP_HEAD_QSUB);
			else if (request_flag == HPCBP_REQUEST_QSTAT)
				sprintf(log_buffer, HPCBP_HEAD_QSTAT);
			else if (request_flag == HPCBP_REQUEST_QDEL)
				sprintf(log_buffer, HPCBP_HEAD_QDEL);
			/* log error message */
			log_joberr(-1, id, log_buffer, pjob->ji_qs.ji_jobid);
		}
		hpcbp_soap_uninit(*s);
		goto error;
	}
	return 0;

error:
	if (password) {
		memset(password, 0, tmp_credlen);
		free(password);
		password = NULL;
	}
	return -1;
}

/*
 * hpcbp_pbs_qsub function is responsbile for submitting job to HPCBP Server
 * It calls auto-generated gSOAP-client stub code,prepares request message,
 * connects to the HPCBP Server, parses response message and
 * writes HPCBP job identifier to '<pbs-jobid>.xml' file inside 'temporary
 * directory for the job
 */

int
hpcbp_pbs_qsub(job  *pjob, char **hpcbp_jobid,
	char *hpcbp_reguser_credbuf, size_t hpcbp_reguser_credlen)
{
	char	*id = "hpcbp_pbs_qsub";
	struct	soap				*soap;
	struct 	bes__CreateActivityType 	request;
	struct 	bes__CreateActivityResponseType response;
	struct 	soap_dom_element 		*dom = NULL;
	struct  soap_dom_element		*iter;
	int	jsdl = -1;
	int	apr;
	char   	activity_identifier[_POSIX_PATH_MAX];
	char   	jsdl_script_file_path[_POSIX_PATH_MAX];
	char   	*hpcbp_user_password;
	int	ret = -1;
	char	*jobid = NULL;

	/* Check for pre-conditions */
	ret = hpcbp_precheck(HPCBP_REQUEST_QSUB, pjob, &soap,
		&hpcbp_user_password, NULL, hpcbp_reguser_credbuf,
		hpcbp_reguser_credlen);
	if (ret)
		return -1;

	/* Assign values for other variables */
	(void)sprintf(activity_identifier, "%s/%s.xml",
		tmpdirname(pjob->ji_qs.ji_jobid), pjob->ji_qs.ji_jobid);
	(void)sprintf(jsdl_script_file_path, "%s/%s.jsdl",
		tmpdirname(pjob->ji_qs.ji_jobid), pjob->ji_qs.ji_jobid);
	DBPRT(("%s: activity identifier: %s\n", id, activity_identifier))
	DBPRT(("%s: JSDL script file: %s\n", id, jsdl_script_file_path))

	/* Convert PBS Job request into JSDL document */
	ret= hpcbp_convert_pbstojsdl(jsdl_script_file_path, pjob);
	if (ret)
		goto error;

	/* Open JSDL document and populate its contents into SOAP request */
	jsdl = open(jsdl_script_file_path, O_RDONLY);
	if (jsdl == -1) {
		sprintf(log_buffer, HPCBP_JSDL_OPEN);
		log_joberr(-1, id, log_buffer, pjob->ji_qs.ji_jobid);
		goto error;
	}
	dom = (struct soap_dom_element*)soap_malloc(soap,
		sizeof(struct soap_dom_element));
	if (dom == NULL)
		goto error;

	memset(dom, 0, sizeof(struct soap_dom_element));
	dom->soap = soap_new1(SOAP_DOM_TREE|SOAP_C_UTFSTRING);
	dom->soap->recvfd = jsdl;
	if ((soap_begin_recv(dom->soap)) ||
		(soap_in_xsd__anyType(dom->soap, NULL, dom, NULL) == NULL) ||
		(soap_end_recv(dom->soap))) {

		sprintf(log_buffer, HPCBP_JSDL_READ);
		log_joberr(-1, id, log_buffer, pjob->ji_qs.ji_jobid);
		goto error;
	}

	if (hpcbp_user_password) {
		/*
		 * Traverse through DOM elements and if it finds 'Password'
		 * element, then store decrypted user's credential info
		 * as 'Password' element's data. The number of 'Password'
		 * XML elements present in JSDL document depends on number
		 * of 'DataStaging' XML elements added to it. So read
		 * complete JSDL document and store user's credential
		 * in 'Password' XML element.
		 */
		for (iter = dom; iter; iter = soap_dom_next_element(iter)) {
			if (strcmp(iter->name, "Password") == 0)
				iter->data = strdup(hpcbp_user_password);
		}

		memset(hpcbp_user_password, 0, strlen(hpcbp_user_password));
		free(hpcbp_user_password);
		hpcbp_user_password = NULL;
	}

	memset(&request, 0, sizeof(struct bes__CreateActivityType));
	memset(&response, 0, sizeof(struct bes__CreateActivityResponseType));
	request.bes__ActivityDocument.__any = dom;
	/*
	 * The 'soap_call___bes__CreateActivity' function is a
	 * client-side stub function to submit job to the HPCBP Server.
	 * It takes all input in native language format(c structures),
	 * marshals those strcutures to XML document, sends the
	 * XML document to the HPCBP Server and unmarshal the response
	 * received into a 'response' c strcture.
	 */
	if (soap_call___bes__CreateActivity(soap, hpcbp_webservice_address,
		CREATE_ACTION, &request,
		&response) != SOAP_OK) {
		sprintf(log_buffer, HPCBP_QSUB_CRED);
		log_joberr(-1, id, log_buffer, pjob->ji_qs.ji_jobid);
		goto error;
	} else {
		hpcbp_cleandom(response.__any);
		read_hpcbp_job_identifier(soap, response.__any, &jobid);
		if (jobid == NULL) {
			sprintf(log_buffer, HPCBP_READ_ACT);
			log_joberr(-1, id, log_buffer, pjob->ji_qs.ji_jobid);
			goto error;
		}
		*hpcbp_jobid = jobid;
		/* Store HPCBP Job identifier in file */
		apr = open(activity_identifier,
			O_WRONLY|O_CREAT|O_TRUNC, S_IRUSR|S_IWUSR);
		if (apr == -1) {
			sprintf(log_buffer, HPCBP_CRT_ACT);
			log_joberr(-1, id, log_buffer, pjob->ji_qs.ji_jobid);
			goto error;
		}
		soap_set_namespaces(soap, epr_namespaces);
		soap->sendfd = apr;
		if ((soap_begin_send(soap)) ||
			(soap_out_xsd__anyType(soap, NULL, 0,
			response.__any, NULL)) ||
			soap_end_send(soap)) {
			sprintf(log_buffer, HPCBP_WRITE_ACT);
			log_joberr(-1, id, log_buffer,
				pjob->ji_qs.ji_jobid);
			close(apr);
			goto error;
		}
		close(apr);
	}
	ret = 0;
error:
	if (jsdl != -1)
		close(jsdl);
	if (dom)
		hpcbp_soap_uninit(dom->soap);
	hpcbp_soap_uninit(soap);
	return ret;
}

/*
 * hpcbp_pbs_qdel function is responsible for sending
 * 'terminate/delete' signal to the HPCBP Server.
 * It reads HPCBP Job Identifier, prepares request message,
 * connects to HPCBP Server and returns 'HPCBP_JOB_TERMINATE_SUCCESS'
 * if HPCBP Server is able to terminate the job. Otherwise,
 * returns 'HPCBP_JOB_TERMINATE_FAILED'.
 */

int
hpcbp_pbs_qdel(job *pjob, char *hpcbp_reguser_credbuf,
	size_t hpcbp_reguser_credlen)
{
	char	*id = "hpcbp_pbs_qdel";
	struct 	bes__TerminateActivitiesType request;
	struct 	bes__TerminateActivitiesResponseType response;
	struct 	soap_dom_element *dom = NULL;
	int 	epr = -1;
	int 	ret = HPCBP_JOB_TERMINATE_ERROR;
	struct	soap *soap;
	char activity_identifier[_POSIX_PATH_MAX];

	/* Check for pre-conditions */
	ret = hpcbp_precheck(HPCBP_REQUEST_QDEL, pjob, &soap, NULL, NULL,
		hpcbp_reguser_credbuf, hpcbp_reguser_credlen);
	if (ret)
		return HPCBP_JOB_TERMINATE_ERROR;

	(void)sprintf(activity_identifier, "%s/%s.xml",
		tmpdirname(pjob->ji_qs.ji_jobid), pjob->ji_qs.ji_jobid);
	DBPRT(("%s: activity idenfier: %s\n", id, activity_identifier))
	epr = open(activity_identifier, O_RDONLY);
	if (epr == -1) {
		sprintf(log_buffer, HPCBP_READ_ID);
		log_joberr(-1, id, log_buffer, pjob->ji_qs.ji_jobid);
		goto error;
	}
	dom = (struct soap_dom_element*)soap_malloc(soap,
		sizeof(struct soap_dom_element));
	if (dom == NULL)
		goto error;

	memset(dom, 0, sizeof(struct soap_dom_element));
	dom->soap = soap_new1(SOAP_DOM_TREE|SOAP_C_UTFSTRING);
	dom->soap->recvfd = epr;
	if ((soap_begin_recv(dom->soap)) ||
		(soap_in_xsd__anyType(dom->soap, NULL, dom, NULL) == NULL) ||
		(soap_end_recv(dom->soap))) {
		sprintf(log_buffer, HPCBP_READ_ID);
		log_joberr(-1, id, log_buffer, pjob->ji_qs.ji_jobid);
		goto error;
	}
	memset(&request, 0, sizeof(struct bes__TerminateActivitiesType));
	memset(&response, 0,
		sizeof(struct bes__TerminateActivitiesResponseType));
	request.__any = dom;
	/*
	 * The 'soap_call___bes__TerminateActivities' function
	 * is a client-side stub function to ask the HPCBP Server to send
	 * a terminate signal to the named job. It takes all input in native
	 * language format (c structures), marshals those strcutures to XML
	 * document, sends the XML document to the HPCBP Server and unmarshal
	 * the response received into a 'response' c structure.
	 */
	if (soap_call___bes__TerminateActivities(soap,
		hpcbp_webservice_address, TERMINATE_ACTION,
		request, &response) != SOAP_OK) {
		sprintf(log_buffer, HPCBP_CNT_ERR);
		log_joberr(-1, id, log_buffer, pjob->ji_qs.ji_jobid);
		goto error;
	} else {
		/* Parse 'TerminateActivities' response message */
		ret = hpcbp_parse_qdel_response(soap, response.__any);
		if (ret == HPCBP_JOB_TEMINATE_UNDEFINED) {
			sprintf(log_buffer, HPCBP_READ_QDEL_RES);
			log_joberr(-1, id, log_buffer,
				pjob->ji_qs.ji_jobid);
		} else if (ret == HPCBP_JOB_TERMINATE_FAILED) {
			sprintf(log_buffer, HPCBP_QDEL_CRED);
			log_joberr(-1, id, log_buffer,
				pjob->ji_qs.ji_jobid);
		}
	}
error:
	if (epr != -1)
		close(epr);
	if (dom)
		hpcbp_soap_uninit(dom->soap);
	hpcbp_soap_uninit(soap);
	return ret;
}

/*
 * hpcbp_pbs_qstat is a client-side function responsible
 * for finding status of job. It reads HPCBP Job Identifier,
 * prepares request message, and returns status of the job
 * to the calling program
 */

int
hpcbp_pbs_qstat(char *pbs_jobid)
{
	char	*id = "hpcbp_pbs_qstat";
	struct 	bes__GetActivityStatusesType request;
	struct 	bes__GetActivityStatusesResponseType response;
	struct 	soap_dom_element *dom = NULL;
	int 	epr = -1;
	char 	activity_identifier[_POSIX_PATH_MAX];
	struct	soap *soap;
	int 	state = HPCBP_JOB_STATE_UNKNOWN; /* store's state of job */
	int	ret = -1;

	/* Check for pre-conditions */
	ret = hpcbp_precheck(HPCBP_REQUEST_QSTAT, NULL, &soap, NULL,
		pbs_jobid, NULL, 0);
	if (ret)
		return state;

	(void)sprintf(activity_identifier, "%s/%s.xml",
		tmpdirname(pbs_jobid), pbs_jobid);
	DBPRT(("%s: activity idenfier: %s\n", id, activity_identifier))
	/* Open activity identifier file */
	epr = open(activity_identifier, O_RDONLY);
	if (epr == -1) {
		/*
		 * HPCBP MOM is not able to open
		 * activity identifier file(which contains HPCBP Job
		 * identifier) means it can't find status of this particular
		 * job. Then return 'HPCBP_JOB_STATE_UNKNOWN' as status.
		 * If this function is called from Parent MOM process
		 * then it kills the child process(responsbile for job).
		 * If it is called from child process, then it
		 * exits with non-zero exit value.
		 */
		sprintf(log_buffer, HPCBP_READ_ID);
		log_joberr(-1, id, log_buffer, pbs_jobid);
		goto error;
	}
	dom = (struct soap_dom_element*)soap_malloc(soap,
		sizeof(struct soap_dom_element));
	if (dom == NULL)
		goto error;

	memset(dom, 0, sizeof(struct soap_dom_element));
	dom->soap = soap_new1(SOAP_DOM_TREE|SOAP_C_UTFSTRING);
	dom->soap->recvfd = epr;
	if ((soap_begin_recv(dom->soap)) ||
		(soap_in_xsd__anyType(dom->soap, NULL, dom, NULL) == NULL) ||
		(soap_end_recv(dom->soap))) {
		sprintf(log_buffer, HPCBP_READ_ID);
		log_joberr(-1, id, log_buffer, pbs_jobid);
		goto error;
	}
	memset(&request, 0, sizeof(struct bes__GetActivityStatusesType));
	memset(&response, 0,
		sizeof(struct bes__GetActivityStatusesResponseType));
	request.__any = dom;
	/*
	 * The 'soap_call___bes__GetActivityStatuses' function is a
	 * client-side stub function to find the status of the job
	 * running at HPCBP Server. It takes all input in native language
	 * format (c structures), marshal those strcutures to XML document,
	 * sends the XML document to the HPCBP Server and unmarshal the
	 * response received into a 'response' c strcture.
	 */
	if (soap_call___bes__GetActivityStatuses(soap,
		hpcbp_webservice_address, STATUS_ACTION,
		request, &response) != SOAP_OK) {
		sprintf(log_buffer, HPCBP_CNT_ERR);
		log_joberr(-1, id, log_buffer, pbs_jobid);
		goto error;
	} else {
		/* Parse 'GetActivityStatuses' response message */
		state = hpcbp_parse_qstat_response(soap, response.__any);
		if (state == HPCBP_JOB_STATE_UNKNOWN) {
			sprintf(log_buffer, HPCBP_READ_QSTAT_RES);
			log_joberr(-1, id, log_buffer, pbs_jobid);
		}
	}
error:
	if (epr != -1)
		close(epr);
	if (dom)
		hpcbp_soap_uninit(dom->soap);
	hpcbp_soap_uninit(soap);
	return state;
}

/*
 * hpcbp_pbs_pbsnodes function is used to find stauts of
 * nodes/job usage information. It prepares request message,
 * connects to the HPCBP Server and parses response message.
 */

int
hpcbp_pbs_pbsnodes(int node_status_flag, char *pbs_jobid , char *hpcbp_jobid)
{
	static char id[] = "hpcbp_pbs_pbsnodes";
	struct 	bes__GetFactoryAttributesDocumentType request;
	struct 	bes__GetFactoryAttributesDocumentResponseType response;
	struct	soap_dom_element *dom = NULL;
	int	ret;
	FILE	*fp = NULL;
	struct	soap	*soap;
	char 	file_name[_POSIX_PATH_MAX];
	int	file = -1;

	/* Check for pre-conditions */
	if (hpcbp_precheck(HPCBP_REQUEST_PBSNODES, NULL, &soap, NULL,
		NULL, NULL, 0) != 0) {
		/*
		 * Free vnode strcuture, if any (created in previous
		 * iteration of the MOM main loop).
		 */
		if (vnlp != NULL) {
			vnl_free(vnlp);
			vnlp = NULL;
		}
		return -1;
	}

	ret = -1;
	if (node_status_flag == HPCBP_NODE_STATUS) {
		(void)sprintf(file_name, "%s/%s/%s",
			pbs_conf.pbs_home_path, MOM_PRIV, HPCBP_NODE_FILE);
		if (access(file_name, F_OK | R_OK)) {
			fp = fopen(file_name, "w");
			if (fp == NULL) {
				sprintf(log_buffer, HPCBP_NODES_XML);
				log_event(PBSEVENT_SYSTEM, PBS_EVENTCLASS_NODE,
					LOG_ERR, id, log_buffer);
				goto error;
			}
			(void)fprintf(fp, "<%s xmlns:hpcp-af=\"%s\"> \n",
				AF_ELEMENT, AF_SCHEMA);
			(void)fprintf(fp, "\t <%s></%s>\n", AF_NODESTATUS,
				AF_NODESTATUS);
			(void)fprintf(fp, "\t <%s>0</%s>\n", AF_ACTIVITYID,
				AF_ACTIVITYID);
			(void)fprintf(fp, "</%s>", AF_ELEMENT);
			if (ferror(fp)) {
				sprintf(log_buffer, HPCBP_NODES_XML);
				log_event(PBSEVENT_SYSTEM, PBS_EVENTCLASS_NODE,
					LOG_ERR, id, log_buffer);
			}
			fclose(fp);
		}
	} else {
		sprintf(log_buffer, HPCBP_PBS_INVALID);
		log_event(PBSEVENT_SYSTEM, PBS_EVENTCLASS_NODE,
			LOG_ERR, id, log_buffer);
		goto error;

	}
	DBPRT(("%s: file name: %s\n", id, file_name))
	memset(&request, 0,
		sizeof(struct bes__GetFactoryAttributesDocumentType));
	memset(&response, 0,
		sizeof(struct bes__GetFactoryAttributesDocumentResponseType));
	/* Populating contents of file to SOAP request message */
	file = open(file_name, O_RDONLY);
	dom = (struct soap_dom_element*)soap_malloc(soap,
		sizeof(struct soap_dom_element));
	if (dom == NULL)
		goto error;

	memset(dom, 0, sizeof(struct soap_dom_element));
	dom->soap = soap_new1(SOAP_DOM_TREE|SOAP_C_UTFSTRING);
	dom->soap->recvfd = file;
	if ((soap_begin_recv(dom->soap)) ||
		(soap_in_xsd__anyType(dom->soap, NULL, dom, NULL) == NULL) ||
		(soap_end_recv(dom->soap))) {
		sprintf(log_buffer, HPCBP_FILE_CONT);
		log_event(PBSEVENT_SYSTEM, PBS_EVENTCLASS_NODE,
			LOG_ERR, id, log_buffer);
		goto error;
	}
	request.__any = dom;
	/*
	 * The 'soap_call___bes__GetFactoryAttributesDocument' function is
	 * a client-side stub function to retrieve status of nodes present
	 * at HPCBP Server. It takes all input in native language
	 * format (c structures), marshals those strcutures to XML document,
	 * sends the XML document to the HPCBP Server and unmarshal
	 * the response received into a 'response' c strcture.
	 */
	if (soap_call___bes__GetFactoryAttributesDocument(soap,
		hpcbp_webservice_address, FACTORY_ACTION,
		request, &response) != SOAP_OK) {
		sprintf(log_buffer, HPCBP_CNT_ERR);
		log_event(PBSEVENT_SYSTEM, PBS_EVENTCLASS_NODE,
			LOG_ERR, id, log_buffer);
		goto error;
	} else {
		hpcbp_parse_pbsnodes_response(soap,
			response.__any, &vnlp);

	}
	ret = 0;
error:
	if (file != -1)
		close(file);
	if (dom)
		hpcbp_soap_uninit(dom->soap);
	if ((ret) && (vnlp != NULL)) {
		vnl_free(vnlp);
		vnlp = NULL;
	}
	hpcbp_soap_uninit(soap);
	return ret;
}
