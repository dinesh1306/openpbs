/*
 * Copyright (C) 1994-2018 Altair Engineering, Inc.
 * For more information, contact Altair at www.altair.com.
 *
 * This file is part of the PBS Professional("PBS Pro") software.
 *
 * Open Source License Information:
 *
 * PBS Pro is free software. You can redistribute it and/or modify it under the
 * terms of the GNU Affero General Public License as published by the Free
 * Software Foundation, either version 3 of the License, or (at your option) any
 * later version.
 *
 * PBS Pro is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.
 * See the GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Commercial License Information:
 *
 * For a copy of the commercial license terms and conditions,
 * go to: (http://www.pbspro.com/UserArea/agreement.html)
 * or contact the Altair Legal Department.
 *
 * Altair’s dual-license business model allows companies, individuals, and
 * organizations to create proprietary derivative works of PBS Pro and
 * distribute them - whether embedded or bundled with other software -
 * under a commercial license agreement.
 *
 * Use of Altair’s trademarks, including but not limited to "PBS™",
 * "PBS Professional®", and "PBS Pro™" and Altair’s logos is subject to Altair's
 * trademark licensing policies.
 *
 */
/**
 * @file	perpare_path.c
 * @brief
 *	Prepare a full path name to give to the server.
 *
 */

#include <pbs_config.h>   /* the master config generated by configure */

#include <errno.h>
#include <netdb.h>
#include <sys/stat.h>
#include "cmds.h"
#include "pbs_ifl.h"
#include "net_connect.h"



/**
 * @brief
 * 	validate if hname is local host
 *
 * @param[in] hname - host name
 * 
 * @return	int
 * @retval	0	success
 * @retval 	1	error
 *
 */
int
is_local_host(char *hname)
{
	char hname_full[PBS_MAXSERVERNAME+1];
	char cname_short[PBS_MAXSERVERNAME+1];
	char cname_full[PBS_MAXSERVERNAME+1];

	if (gethostname(cname_short, PBS_MAXSERVERNAME) != 0)
		return (0);
	/*
	 * Compare with "locahost" and "localhost.localdomain".
	 */
#ifdef WIN32
	if (stricmp(hname, cname_short) == 0 ||
		stricmp(hname, LOCALHOST_SHORTNAME) == 0 ||
		stricmp(hname, LOCALHOST_FULLNAME)== 0)
		return (1);
#else
	if (strcmp(hname, cname_short) == 0 ||
		strcmp(hname, LOCALHOST_SHORTNAME) == 0 ||
		strcmp(hname, LOCALHOST_FULLNAME)== 0)
		return (1);
#endif
	if (get_fullhostname(cname_short, cname_full, PBS_MAXSERVERNAME) != 0)
		return (0);
	
	if (get_fullhostname(hname, hname_full, PBS_MAXSERVERNAME) != 0)
		return (0);
	
	if (strcmp(hname_full, cname_full) == 0)
		return (1);
	
	return (0);
}


/**
 * @brief
 *	parses path and prepares complete path name
 *
 * @param[in]      path_in - the path name provided as input to be parsed
 * @param[in/out]  path_out - contains final parsed and prepared path
 *
 * @return int
 * @retval  0   success in parsing
 * @retval -1	error encountered in parsing
 */
int
prepare_path(char *path_in, char *path_out)
{
	int i = 0;
	char *c = NULL;
	int have_fqdn = 0;
	char host_name[PBS_MAXSERVERNAME+1] = {'\0'};	/* short host name */
	char host_fqdn[PBS_MAXSERVERNAME+1] = {'\0'};	/* fully qualified domain name */
	int h_pos = 0;
	char path_name[MAXPATHLEN+1] = {'\0'};
	int p_pos = 0;
	char cwd[MAXPATHLEN+1] = {'\0'};
	char *host_given = NULL;
	struct stat statbuf = {0};
	dev_t dev = 0;
	ino_t ino = 0;

	/* initialize data for this parsing call */
	for (i=0; i<= PBS_MAXSERVERNAME; i++) host_name[i]='\0';
	h_pos = 0;
	for (i=0; i<= MAXPATHLEN; i++) path_name[i]='\0';
	p_pos = 0;
	cwd[MAXPATHLEN] = '\0';

	/* Begin the parse */
	c = path_in;
	while ((int)isspace(*c)) c++;
	if (strlen(c) == 0) return 1;

	/* Looking for a hostname :  */
	if ((host_given=strchr(path_in, ':')) != NULL) {
		while (*c != ':' && *c != '\0') {
			if (isalnum(*c) || (*c == '.') || (*c == '-') || (*c == '_'))
				host_name[h_pos++]=*c;
			else
				break;
			c++;
		}
	}

#ifdef WIN32
	if (strlen(host_name) == 1 && isalpha(host_name[0])) { /* found drive */
		host_given = NULL;
		host_name[0] = '\0';
		c = path_in;
	}
#endif

	/* Looking for a posix path */
	if ((*c == ':') || (c == path_in)) {
		if (*c == ':') c++;
		while (*c != '\0') {
			if (isprint(*c))
				path_name[p_pos++]=*c;
			else
				break;
			c++;
		}
	}

	/* we had trailing trash, or a parse error */
	if (*c != '\0') return 1;
	if (strlen(path_name) == 0 && strlen(host_name) == 0)
		return 1;

	/* appending a slash in the end to indicate that it is a directory */
	if (path_name[strlen(path_name) - 1]
			!= '/'&& path_name[strlen(path_name)-1] != '\\' && stat(path_name, &statbuf) == 0 && S_ISDIR(statbuf.st_mode))
		strncat(path_name, "/", 1);

#ifdef WIN32
	if (IS_UNCPATH(path_name)) {
		/*
		 * given path is UNC path
		 * so just skip hostname
		 * as UNC path dose not require it
		 */
		host_given = NULL;
		host_name[0] = '\0';
		path_out[0] = '\0';
	} else {
#endif
		/* get full host name */
		if (host_name[0] == '\0') {
			if (pbs_conf.pbs_output_host_name) {
				/* use the specified host for returning the file */
				strncpy(host_name, pbs_conf.pbs_output_host_name, PBS_MAXSERVERNAME);
				have_fqdn = 1;
			} else {
				if (gethostname(host_name, PBS_MAXSERVERNAME) != 0)
					return 2;
			}
		}
		if (have_fqdn == 0) {
			/* need to fully qualify the host name */
			if (get_fullhostname(host_name, host_fqdn, PBS_MAXSERVERNAME) != 0)
				return 2;
			strncpy(path_out, host_fqdn, strlen(host_fqdn));	/* FQ host name */
		} else {
			strncpy(path_out, host_name, strlen(host_name));	/* "localhost" or pbs_output_host_name */
		}

		/* finish preparing complete host name */
		strncat(path_out, ":", strlen(":"));
#ifdef WIN32
	}

	if ( path_name[0] != '/' && path_name[0] != '\\' && \
		host_given == NULL &&  strchr(path_name, ':') == NULL )
#else
	if (path_name[0] != '/' && host_given == NULL)
#endif
	{
		c = getenv("PWD");		/* PWD carries a name that will cause */
		if (c != NULL) {		/* the NFS to mount */

			if (stat(c, &statbuf) < 0) {	/* can't stat PWD */
				c = NULL;
			} else {
				dev = statbuf.st_dev;
				ino = statbuf.st_ino;
				if (stat(".", &statbuf) < 0) {
					perror("prepare_path: cannot stat current directory:");
					return (1);
				}
			}
			if (dev == statbuf.st_dev && ino == statbuf.st_ino) {
				strcpy(cwd, c);
			} else {
				c = NULL;
			}
		}
		if (c == NULL) {
			c = getcwd(cwd, MAXPATHLEN);
			if (c == NULL) {
				perror("prepare_path: getcwd failed : ");
				return (1);
			}
		}
#ifdef WIN32
		/* get UNC path (if available) if it is mapped drive */
		get_uncpath(cwd);
		if (IS_UNCPATH(cwd)) {
			strcpy(path_out, cwd);
			if (cwd[strlen(cwd)-1] != '\\')
				strcat(path_out, "\\");
		} else {
#endif
			strcat(path_out, cwd);
			strcat(path_out, "/");
#ifdef WIN32
		}
#endif
	}


#ifdef WIN32
	/* get UNC path (if available) if it is mapped drive */
	get_uncpath(path_name);
	if (IS_UNCPATH(path_name))
		strcpy(path_out, path_name);
	else {
		/*
		 * check whether given <path_name> is relative path
		 * without drive on localhost and <cwd> is not UNC path?
		 * if yes then do not append drive into <path_out>
		 * otherwise append drive into <path_out>
		 */
		if(is_local_host(host_name) && \
			(strchr(path_name, ':') == NULL) && \
			(path_out[strlen(path_out)-1] != '/') && \
			(!IS_UNCPATH(path_out))) {

			char drivestr[3] = {'\0'};
			char drivestr_unc[MAXPATHLEN+1] = {'\0'};

			drivestr[0] = _getdrive() + 'A' - 1;
			drivestr[1] = ':';
			drivestr[2] = '\0';
			/*
			 * check whether <drivestr> is mapped drive?
			 * by calling get_uncpath()
			 * if yes then remove <hostname> part from <path_out>
			 *
			 * This is the case when user submit job
			 * from mapped drive with relative path without drive
			 * in path ex. localhost:err or localhost:out
			 */
			snprintf(drivestr_unc, sizeof(drivestr_unc), "%s\\", drivestr);
			get_uncpath(drivestr_unc);
			if (IS_UNCPATH(drivestr_unc)) {
				strncpy(path_out, drivestr_unc, strlen(drivestr_unc));
			} else {
				strncat(path_out, drivestr, strlen(drivestr));
			}
		}
		strncat(path_out, path_name, strlen(path_name));
	}
	back2forward_slash(path_out);	/* "\" translate to "/" for path */
	strcpy(path_out, replace_space(path_out, "\\ "));
#else
	strcat(path_out, path_name);
#endif

	return (0);
}
